<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOM6: mom_entrain_diffusive Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOM6
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacemom__entrain__diffusive.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">mom_entrain_diffusive Module Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:acf36bae78e6175d37c3de0d61b0ac32f"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#acf36bae78e6175d37c3de0d61b0ac32f">entrainment_diffusive</a> (u, v, h, tv, fluxes, dt, G, GV, CS, ea, eb, kb_out, Kd_Lay, Kd_int)</td></tr>
<tr class="memdesc:acf36bae78e6175d37c3de0d61b0ac32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine calculates ea and eb, the rates at which a layer entrains from the layers above and below. The entrainment rates are proportional to the buoyancy flux in a layer and inversely proportional to the density differences between layers. The scheme that is used here is described in detail in Hallberg, Mon. Wea. Rev. 2000.  <a href="#acf36bae78e6175d37c3de0d61b0ac32f">More...</a><br /></td></tr>
<tr class="separator:acf36bae78e6175d37c3de0d61b0ac32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bbe9f35e3198470100375d9d016b7a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#a13bbe9f35e3198470100375d9d016b7a">f_to_ent</a> (F, h, kb, kmb, j, G, GV, CS, dsp1_ds, eakb, Ent_bl, ea, eb, do_i_in)</td></tr>
<tr class="memdesc:a13bbe9f35e3198470100375d9d016b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine calculates the actual entrainments (ea and eb) and the amount of surface forcing that is applied to each layer if there is no bulk mixed layer.  <a href="#a13bbe9f35e3198470100375d9d016b7a">More...</a><br /></td></tr>
<tr class="separator:a13bbe9f35e3198470100375d9d016b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb7f6c11941a32adc279456c4c165ad"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#a4cb7f6c11941a32adc279456c4c165ad">set_ent_bl</a> (h, dtKd_int, tv, kb, kmb, do_i, G, GV, CS, j, Ent_bl, Sref, h_bl)</td></tr>
<tr class="memdesc:a4cb7f6c11941a32adc279456c4c165ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine sets the average entrainment across each of the interfaces between buffer layers within a timestep. It also causes thin and relatively light interior layers to be entrained by the deepest buffer layer. Also find the initial coordinate potential densities (Sref) of each layer.  <a href="#a4cb7f6c11941a32adc279456c4c165ad">More...</a><br /></td></tr>
<tr class="separator:a4cb7f6c11941a32adc279456c4c165ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d2f462912ba1e201b1b73e62a905f3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#aa2d2f462912ba1e201b1b73e62a905f3">determine_dskb</a> (h_bl, Sref, Ent_bl, E_kb, is, ie, kmb, G, GV, limit, dSkb, ddSkb_dE, dSlay, ddSlay_dE, dS_anom_lim, do_i_in)</td></tr>
<tr class="memdesc:aa2d2f462912ba1e201b1b73e62a905f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine determines the reference density difference between the bottommost buffer layer and the first interior after the mixing between mixed and buffer layers and mixing with the layer below. Within the mixed and buffer layers, entrainment from the layer above is increased when it is necessary to keep the layers from developing a negative thickness; otherwise it equals Ent_bl. At each interface, the upward and downward fluxes average out to Ent_bl, unless entrainment by the layer below is larger than twice Ent_bl. The density difference across the first interior layer may also be returned. It could also be limited to avoid negative values or values that greatly exceed the density differences across an interface. Additionally, the partial derivatives of dSkb and dSlay with E_kb could also be returned.  <a href="#aa2d2f462912ba1e201b1b73e62a905f3">More...</a><br /></td></tr>
<tr class="separator:aa2d2f462912ba1e201b1b73e62a905f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce1b1ba57f5245f1eda57e7a254d4df"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#adce1b1ba57f5245f1eda57e7a254d4df">f_kb_to_ea_kb</a> (h_bl, Sref, Ent_bl, I_dSkbp1, F_kb, kmb, i, G, GV, CS, ea_kb, tol_in)</td></tr>
<tr class="separator:adce1b1ba57f5245f1eda57e7a254d4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541b3aadc418110f7359b0ae401e4e78"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#a541b3aadc418110f7359b0ae401e4e78">determine_ea_kb</a> (h_bl, dtKd_kb, Sref, I_dSkbp1, Ent_bl, ea_kbp1, min_eakb, max_eakb, kmb, is, ie, do_i, G, GV, CS, Ent, error, err_min_eakb0, err_max_eakb0, F_kb, dFdfm_kb)</td></tr>
<tr class="separator:a541b3aadc418110f7359b0ae401e4e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45dbf976314c3a9e278ebcebedab109"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#ae45dbf976314c3a9e278ebcebedab109">find_maxf_kb</a> (h_bl, Sref, Ent_bl, I_dSkbp1, min_ent_in, max_ent_in, kmb, is, ie, G, GV, CS, maxF, ent_maxF, do_i_in, F_lim_maxent, F_thresh)</td></tr>
<tr class="separator:ae45dbf976314c3a9e278ebcebedab109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77feea714cc9f7174c7bd07058a5cc73"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#a77feea714cc9f7174c7bd07058a5cc73">entrain_diffusive_init</a> (Time, G, GV, param_file, diag, CS)</td></tr>
<tr class="separator:a77feea714cc9f7174c7bd07058a5cc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e71b47abe1e1889f4b687139615ca14"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemom__entrain__diffusive.html#a0e71b47abe1e1889f4b687139615ca14">entrain_diffusive_end</a> (CS)</td></tr>
<tr class="separator:a0e71b47abe1e1889f4b687139615ca14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="aa2d2f462912ba1e201b1b73e62a905f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d2f462912ba1e201b1b73e62a905f3">&#9670;&nbsp;</a></span>determine_dskb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mom_entrain_diffusive::determine_dskb </td>
          <td>(</td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>h_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>Sref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>Ent_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>E_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>kmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in)&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(inout)&#160;</td>
          <td class="paramname"><em>dSkb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(inout), optional&#160;</td>
          <td class="paramname"><em>ddSkb_dE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(inout), optional&#160;</td>
          <td class="paramname"><em>dSlay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(inout), optional&#160;</td>
          <td class="paramname"><em>ddSlay_dE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(inout), optional&#160;</td>
          <td class="paramname"><em>dS_anom_lim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension(szi_(g)), intent(in), optional&#160;</td>
          <td class="paramname"><em>do_i_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subroutine determines the reference density difference between the bottommost buffer layer and the first interior after the mixing between mixed and buffer layers and mixing with the layer below. Within the mixed and buffer layers, entrainment from the layer above is increased when it is necessary to keep the layers from developing a negative thickness; otherwise it equals Ent_bl. At each interface, the upward and downward fluxes average out to Ent_bl, unless entrainment by the layer below is larger than twice Ent_bl. The density difference across the first interior layer may also be returned. It could also be limited to avoid negative values or values that greatly exceed the density differences across an interface. Additionally, the partial derivatives of dSkb and dSlay with E_kb could also be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_bl</td><td>Layer thickness, in m or kg m-2 (abbreviated as H below).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sref</td><td>Reference potential vorticity (in kg m-3?).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ent_bl</td><td>The average entrainment upward and downward across each interface around the buffer layers, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e_kb</td><td>The entrainment by the top interior layer, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ie</td><td>The range of i-indices to work on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kmb</td><td>The number of mixed and buffer layers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>If true, limit dSkb and dSlay to avoid negative values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dskb</td><td>The limited potential density difference across the interface between the bottommost buffer layer and the topmost interior layer. dSkb &gt; 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ddskb_de</td><td>The partial derivative of dSkb with E, in kg m-3 H-1.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dslay</td><td>The limited potential density difference across the topmost interior layer. 0 &lt; dSkb</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ddslay_de</td><td>The partial derivative of dSlay with E, in kg m-3 H-1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_i_in</td><td>If present, determines which columns are worked on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01284">1284</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">References <a class="el" href="MOM__error__handler_8F90_source.html#l00073">mom_error_handler::mom_error()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01653">determine_ea_kb()</a>, <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00111">entrainment_diffusive()</a>, <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01536">f_kb_to_ea_kb()</a>, and <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01890">find_maxf_kb()</a>.</p>
<div class="fragment"><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),              <span class="keywordtype">intent(in)</span>    :: g<span class="comment">      !&lt; The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type),            <span class="keywordtype">intent(in)</span>    :: gv<span class="comment">     !&lt; The ocean&#39;s vertical grid</span></div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;<span class="comment">                                                              !! structure.</span></div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>,   <span class="keywordtype">intent(in)</span>    :: h_bl<span class="comment">   !&lt; Layer thickness, in m or kg m-2</span></div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;<span class="comment">                                                              !! (abbreviated as H below).</span></div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>,   <span class="keywordtype">intent(in)</span>    :: sref<span class="comment">   !&lt; Reference potential vorticity</span></div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="comment">                                                              !! (in kg m-3?).</span></div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>,   <span class="keywordtype">intent(in)</span>    :: ent_bl<span class="comment"> !&lt; The average entrainment upward and</span></div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;<span class="comment">                                                              !! downward across each interface</span></div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;<span class="comment">                                                              !! around the buffer layers, in H.</span></div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,           <span class="keywordtype">intent(in)</span>    :: e_kb<span class="comment">   !&lt; The entrainment by the top interior</span></div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="comment">                                                              !! layer, in H.</span></div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;  <span class="keywordtype">integer</span>,                            <span class="keywordtype">intent(in)</span>    :: is, ie<span class="comment"> !&lt; The range of i-indices to work on.</span></div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;  <span class="keywordtype">integer</span>,                            <span class="keywordtype">intent(in)</span>    :: kmb<span class="comment">    !&lt; The number of mixed and buffer</span></div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;<span class="comment">                                                              !! layers.</span></div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;  <span class="keywordtype">logical</span>,                            <span class="keywordtype">intent(in)</span>    :: limit<span class="comment">  !&lt; If true, limit dSkb and dSlay to</span></div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="comment">                                                              !! avoid negative values.</span></div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,           <span class="keywordtype">intent(inout)</span> :: dskb<span class="comment">   !&lt; The limited potential density</span></div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;<span class="comment">                                                              !! difference across the interface</span></div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;<span class="comment">                                                              !! between the bottommost buffer layer</span></div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;<span class="comment">                                                              !! and the topmost interior layer.</span></div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;<span class="comment">                                                              !! dSkb &gt; 0.</span></div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">optional</span>, <span class="keywordtype">intent(inout)</span> :: ddskb_de<span class="comment">  !&lt; The partial derivative of dSkb</span></div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="comment">                                                              !! with E, in kg m-3 H-1.</span></div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">optional</span>, <span class="keywordtype">intent(inout)</span> :: dslay<span class="comment">     !&lt; The limited potential density</span></div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;<span class="comment">                                                              !! difference across the topmost</span></div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="comment">                                                              !! interior layer. 0 &lt; dSkb</span></div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">optional</span>, <span class="keywordtype">intent(inout)</span> :: ddslay_de<span class="comment"> !&lt; The partial derivative of dSlay</span></div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="comment">                                                              !! with E, in kg m-3 H-1.</span></div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">optional</span>, <span class="keywordtype">intent(inout)</span> :: ds_anom_lim</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">optional</span>, <span class="keywordtype">intent(in)</span> :: do_i_in<span class="comment">   !&lt; If present, determines which</span></div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="comment">                                                              !! columns are worked on.</span></div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="comment">! Arguments: h_bl - Layer thickness, in m or kg m-2 (abbreviated as H below).</span></div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="comment">!  (in)      Sref - Reference potential vorticity (in kg m-3?)</span></div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="comment">!  (in)      Ent_bl - The average entrainment upward and downward across</span></div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="comment">!                     each interface around the buffer layers, in H.</span></div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;<span class="comment">!  (in)      E_kb - The entrainment by the top interior layer, in H.</span></div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;<span class="comment">!  (in)      is, ie - The range of i-indices to work on.</span></div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="comment">!  (in)      kmb - The number of mixed and buffer layers.</span></div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="comment">!  (in)      G - The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="comment">!  (in)      GV - The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;<span class="comment">!  (in)      limit - If true, limit dSkb and dSlay to avoid negative values.</span></div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="comment">!  (out)     dSkb - The limited potential density difference across the</span></div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="comment">!                   interface between the bottommost buffer layer and the</span></div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="comment">!                   topmost interior layer.  dSkb &gt; 0.</span></div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="comment">!  (out,opt) dSlay - The limited potential density difference across the</span></div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;<span class="comment">!                        topmost interior layer. 0 &lt; dSkb</span></div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="comment">!  (out,opt) ddSkb_dE - The partial derivative of dSkb with E, in kg m-3 H-1.</span></div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="comment">!  (out,opt) ddSlay_dE - The partial derivative of dSlay with E, in kg m-3 H-1.</span></div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="comment">!  (in,opt)  do_i_in - If present, determines which columns are worked on.</span></div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="comment">! Note that dSkb, ddSkb_dE, dSlay, ddSlay_dE, and dS_anom_lim are declared</span></div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="comment">! intent(inout) because they should not change where do_i_in is false.</span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;<span class="comment">!   This subroutine determines the reference density difference between the</span></div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="comment">! bottommost buffer layer and the first interior after the mixing between mixed</span></div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="comment">! and buffer layers and mixing with the layer below. Within the mixed and buffer</span></div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="comment">! layers, entrainment from the layer above is increased when it is necessary to</span></div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="comment">! keep the layers from developing a negative thickness; otherwise it equals</span></div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="comment">! Ent_bl.  At each interface, the upward and downward fluxes average out to</span></div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="comment">! Ent_bl, unless entrainment by the layer below is larger than twice Ent_bl.</span></div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;<span class="comment">!   The density difference across the first interior layer may also be returned.</span></div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="comment">! It could also be limited to avoid negative values or values that greatly</span></div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="comment">! exceed the density differences across an interface.</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="comment">!   Additionally, the partial derivatives of dSkb and dSlay with E_kb could</span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="comment">! also be returned.</span></div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span> :: &amp;</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    b1, c1, &amp;       <span class="comment">! b1 and c1 are variables used by the tridiagonal solver.</span></div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;    s, ds_de, &amp;     <span class="comment">! The coordinate density and its derivative with R.</span></div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;    ea, dea_de, &amp;   <span class="comment">! The entrainment from above and its derivative with R.</span></div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;    eb, deb_de      <span class="comment">! The entrainment from below and its derivative with R.</span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;  <span class="keywordtype">real</span> :: deriv_dskb(szi_(g))</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;  <span class="keywordtype">real</span> :: d1(szi_(g))  <span class="comment">! d1 = 1.0-c1 is also used by the tridiagonal solver.</span></div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;  <span class="keywordtype">real</span> :: src       <span class="comment">! A source term for dS_dR.</span></div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;  <span class="keywordtype">real</span> :: h1        <span class="comment">! The thickness in excess of the minimum that will remain</span></div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;                    <span class="comment">! after exchange with the layer below, in m or kg m-2.</span></div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: do_i</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;  <span class="keywordtype">real</span> :: h_neglect <span class="comment">! A thickness that is so small it is usually lost</span></div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;                    <span class="comment">! in roundoff and can be neglected, in H.</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;  <span class="keywordtype">real</span> :: h_tr      <span class="comment">! h_tr is h at tracer points with a tiny thickness</span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;                    <span class="comment">! added to ensure positive definiteness, in m or kg m-2.</span></div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;  <span class="keywordtype">real</span> :: b_denom_1 <span class="comment">! The first term in the denominator of b1 in m or kg m-2.</span></div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;  <span class="keywordtype">real</span> :: rat</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;  <span class="keywordtype">real</span> :: ds_kbp1, ids_kbp1</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;  <span class="keywordtype">real</span> :: deriv_dslay</div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;  <span class="keywordtype">real</span> :: inv_term     <span class="comment">! Nondimensional.</span></div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;  <span class="keywordtype">real</span> :: f1, df1_drat <span class="comment">! Nondimensional temporary variables.</span></div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;  <span class="keywordtype">real</span> :: z, dz_drat, f2, df2_dz, expz <span class="comment">! Nondimensional temporary variables.</span></div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;  <span class="keywordtype">real</span> :: eps_dslay, eps_dskb <span class="comment">! Small nondimensional constants.</span></div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;  <span class="keywordtype">integer</span> :: i, k</div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(ddslay_de) .and. .not.<span class="keyword">present</span>(dslay)) <span class="keyword">call </span>mom_error(fatal, &amp;</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;      <span class="stringliteral">&quot;In deterimine_dSkb, ddSLay_dE may only be present if dSlay is.&quot;</span>)</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;  h_neglect = gv%H_subroundoff</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;  <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;    ea(i,kmb+1) = e_kb(i) ; dea_de(i,kmb+1) = 1.0</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;    s(i,kmb+1) = sref(i,kmb+1) ; ds_de(i,kmb+1) = 0.0</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;    b1(i,kmb+1) = 0.0</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;    d1(i) = 1.0</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;    do_i(i) = .true.</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(do_i_in)) <span class="keywordflow">then</span></div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; do_i(i) = do_i_in(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;  <span class="keywordflow">do</span> k=kmb,1,-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;    <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;      <span class="comment">! The do_i test here is only for efficiency.</span></div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;    <span class="comment">! Determine the entrainment from below for each buffer layer.</span></div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;      <span class="keywordflow">if</span> (2.0*ent_bl(i,k+1) &gt; ea(i,k+1)) <span class="keywordflow">then</span></div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;        eb(i,k) = 2.0*ent_bl(i,k+1) - ea(i,k+1) ; deb_de(i,k) = -dea_de(i,k+1)</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;        eb(i,k) = 0.0 ; deb_de(i,k) = 0.0</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;      <span class="comment">! Determine the entrainment from above for each buffer layer.</span></div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;      h1 = (h_bl(i,k) - gv%Angstrom) + (eb(i,k) - ea(i,k+1))</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;      <span class="keywordflow">if</span> (h1 &gt;= 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;        ea(i,k) = ent_bl(i,k) ; dea_de(i,k) = 0.0</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;      <span class="keywordflow">elseif</span> (ent_bl(i,k) + 0.5*h1 &gt;= 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;        ea(i,k) = ent_bl(i,k) - 0.5*h1</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;        dea_de(i,k) = 0.5*(dea_de(i,k+1) - deb_de(i,k))</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;        ea(i,k) = -h1</div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;        dea_de(i,k) = dea_de(i,k+1) - deb_de(i,k)</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;      ea(i,k) = 0.0 ; dea_de(i,k) = 0.0 ; eb(i,k) = 0.0 ; deb_de(i,k) = 0.0</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;</div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;    <span class="comment">! This is the first-pass of a tridiagonal solver for S.</span></div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;    h_tr = h_bl(i,k) + h_neglect</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;    c1(i,k) = ea(i,k+1) * b1(i,k+1)</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;    b_denom_1 = (h_tr + d1(i)*eb(i,k))</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;    b1(i,k) = 1.0 / (b_denom_1 + ea(i,k))</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;    d1(i) = b_denom_1 * b1(i,k)</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;    s(i,k) = (h_tr*sref(i,k) + eb(i,k)*s(i,k+1)) * b1(i,k)</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;<span class="keywordflow">  enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;  <span class="keywordflow">do</span> k=2,kmb ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;    s(i,k) = s(i,k) + c1(i,k-1)*s(i,k-1)</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="keywordflow">  enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;</div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(ddskb_de) .or. <span class="keyword">present</span>(ddslay_de)) <span class="keywordflow">then</span></div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;    <span class="comment">! These two tridiagonal solvers cannot be combined because the solutions for</span></div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;    <span class="comment">! S are required as a source for dS_dE.</span></div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;    <span class="keywordflow">do</span> k=kmb,2,-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;      <span class="keywordflow">if</span> (do_i(i) .and. (dea_de(i,k) - deb_de(i,k) &gt; 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;        src = (((s(i,k+1) - sref(i,k)) * (h_bl(i,k) + h_neglect) + &amp;</div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;                (s(i,k+1) - s(i,k-1)) * ea(i,k)) * deb_de(i,k) - &amp;</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;               ((sref(i,k) - s(i,k-1)) * h_bl(i,k) + &amp;</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;                (s(i,k+1) - s(i,k-1)) * eb(i,k)) * dea_de(i,k)) / &amp;</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;              ((h_bl(i,k) + h_neglect + ea(i,k)) + eb(i,k))</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;      <span class="keywordflow">else</span> ; src = 0.0 ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;      ds_de(i,k) = (src + eb(i,k)*ds_de(i,k+1)) * b1(i,k)</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;<span class="keywordflow">    enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;      <span class="keywordflow">if</span> (do_i(i) .and. (deb_de(i,1) &lt; 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;        src = (((s(i,2) - sref(i,1)) * (h_bl(i,1) + h_neglect)) * deb_de(i,1)) / &amp;</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;              (h_bl(i,1) + h_neglect + eb(i,1))</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;      <span class="keywordflow">else</span> ; src = 0.0 ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;      ds_de(i,1) = (src + eb(i,1)*ds_de(i,2)) * b1(i,1)</div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;    <span class="keywordflow">do</span> k=2,kmb ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;      ds_de(i,k) = ds_de(i,k) + c1(i,k-1)*ds_de(i,k-1)</div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="keywordflow">    enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;</div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;  <span class="comment">! Now, apply any limiting and return the requested variables.</span></div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;  eps_dskb = 1.0e-6   <span class="comment">! Should be a small, nondimensional, positive number.</span></div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;  <span class="keywordflow">if</span> (.not.limit) <span class="keywordflow">then</span></div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;      dskb(i) = sref(i,kmb+1) - s(i,kmb)</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(ddskb_de)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;      ddskb_de(i) = -1.0*ds_de(i,kmb)</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(dslay)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;      dslay(i) = 0.5 * (sref(i,kmb+2) - s(i,kmb))</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(ddslay_de)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;      ddslay_de(i) = -0.5*ds_de(i,kmb)</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;      <span class="comment">! Need to ensure that 0 &lt; dSkb &lt;= S_kb - Sbl</span></div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;      <span class="keywordflow">if</span> (sref(i,kmb+1) - s(i,kmb) &lt; eps_dskb*(sref(i,kmb+2) - sref(i,kmb+1))) <span class="keywordflow">then</span></div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;        dskb(i) = eps_dskb * (sref(i,kmb+2) - sref(i,kmb+1)) ; deriv_dskb(i) = 0.0</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;        dskb(i) = sref(i,kmb+1) - s(i,kmb) ; deriv_dskb(i) = -1.0</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">present</span>(ddskb_de)) ddskb_de(i) = deriv_dskb(i)*ds_de(i,kmb)</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;</div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(dslay)) <span class="keywordflow">then</span></div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;      dz_drat = 1000.0    <span class="comment">! The limit of large dz_drat the same as choosing a</span></div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;                          <span class="comment">! Heaviside function.</span></div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;      eps_dslay = 1.0e-10 <span class="comment">! Should be ~= GV%Angstrom / sqrt(Kd*dt)</span></div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;        ds_kbp1 = sref(i,kmb+2) - sref(i,kmb+1)</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;        ids_kbp1 = 1.0 / (sref(i,kmb+2) - sref(i,kmb+1))</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;        rat = (sref(i,kmb+1) - s(i,kmb)) * ids_kbp1</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;        <span class="comment">! Need to ensure that 0 &lt; dSLay &lt;= 2*dSkb</span></div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;        <span class="keywordflow">if</span> (rat &lt; 0.5) <span class="keywordflow">then</span></div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;          <span class="comment">! The coefficients here are chosen so that at rat = 0.5, the value (1.5)</span></div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;          <span class="comment">! and first derivative (-0.5) match with the &quot;typical&quot; case (next).</span></div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;          <span class="comment">! The functional form here is arbitrary.</span></div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;          <span class="comment">!   f1 provides a reasonable profile that matches the value and derivative</span></div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;          <span class="comment">! of the &quot;typical&quot; case at rat = 0.5, and has a maximum of less than 2.</span></div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;          inv_term = 1.0 / (1.0-rat)</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;          f1 = 2.0 - 0.125*(inv_term**2)</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;          df1_drat = - 0.25*(inv_term**3)</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;          <span class="comment">!   f2 ensures that dSLay goes to 0 rapidly if rat is significantly</span></div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;          <span class="comment">! negative.</span></div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;          z = dz_drat * rat + 4.0 <span class="comment">! The 4 here gives f2(0) = 0.982.</span></div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;          <span class="keywordflow">if</span> (z &gt;= 18.0) <span class="keywordflow">then</span> ; f2 = 1.0 ; df2_dz = 0.0</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;          <span class="keywordflow">elseif</span> (z &lt;= -58.0) <span class="keywordflow">then</span> ; f2 = eps_dslay ; df2_dz = 0.0</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;            expz = exp(z) ; inv_term = 1.0 / (1.0 + expz)</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;            f2 = (eps_dslay + expz) * inv_term</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;            df2_dz = (1.0 - eps_dslay) * expz * inv_term**2</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;          dslay(i) = dskb(i) * f1 * f2</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;          deriv_dslay = deriv_dskb(i) * (f1 * f2) - (dskb(i)*ids_kbp1) * &amp;</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;                            (df1_drat*f2 + f1 * dz_drat * df2_dz)</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;        <span class="keywordflow">elseif</span> (dskb(i) &lt;= 3.0*ds_kbp1) <span class="keywordflow">then</span></div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;          <span class="comment">! This is the &quot;typical&quot; case.</span></div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;          dslay(i) = 0.5 * (dskb(i) + ds_kbp1)</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;          deriv_dslay = 0.5 * deriv_dskb(i) <span class="comment">! = -0.5</span></div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;          dslay(i) = 2.0*ds_kbp1</div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;          deriv_dslay = 0.0</div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">present</span>(ddslay_de)) ddslay_de(i) = deriv_dslay*ds_de(i,kmb)</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;<span class="keywordflow">    endif</span> <span class="comment">! present(dSlay)</span></div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;<span class="keywordflow">  endif</span> <span class="comment">! Not limited.</span></div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;</div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(ds_anom_lim)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;    ds_anom_lim(i) = max(0.0, eps_dskb * (sref(i,kmb+2) - sref(i,kmb+1)) - &amp;</div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;                              (sref(i,kmb+1) - s(i,kmb)) )</div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_aa2d2f462912ba1e201b1b73e62a905f3_cgraph.svg" width="543" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_aa2d2f462912ba1e201b1b73e62a905f3_icgraph.svg" width="100%" height="465"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a541b3aadc418110f7359b0ae401e4e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541b3aadc418110f7359b0ae401e4e78">&#9670;&nbsp;</a></span>determine_ea_kb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mom_entrain_diffusive::determine_ea_kb </td>
          <td>(</td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %ke), intent(in)&#160;</td>
          <td class="paramname"><em>h_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(in)&#160;</td>
          <td class="paramname"><em>dtKd_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %ke), intent(in)&#160;</td>
          <td class="paramname"><em>Sref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(in)&#160;</td>
          <td class="paramname"><em>I_dSkbp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %ke), intent(in)&#160;</td>
          <td class="paramname"><em>Ent_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(in)&#160;</td>
          <td class="paramname"><em>ea_kbp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(in)&#160;</td>
          <td class="paramname"><em>min_eakb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(in)&#160;</td>
          <td class="paramname"><em>max_eakb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>kmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension( g %isd: g %ied), intent(in)&#160;</td>
          <td class="paramname"><em>do_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), pointer&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(inout)&#160;</td>
          <td class="paramname"><em>Ent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(out), optional&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in), optional&#160;</td>
          <td class="paramname"><em>err_min_eakb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in), optional&#160;</td>
          <td class="paramname"><em>err_max_eakb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(out), optional&#160;</td>
          <td class="paramname"><em>F_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(out), optional&#160;</td>
          <td class="paramname"><em>dFdfm_kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_bl</td><td>Layer thickness, with the top interior layer at k-index kmb+1, in units of m or kg m-2 (abbreviated as H below).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sref</td><td>The coordinate reference potential density, with the value of the topmost interior layer at layer kmb+1, in units of kg m-3.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ent_bl</td><td>The average entrainment upward and downward across each interface around the buffer layers, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_dskbp1</td><td>The inverse of the difference in reference potential density across the base of the uppermost interior layer, in units of m3 kg-1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtkd_kb</td><td>The diapycnal diffusivity in the top interior layer times the time step, in H2.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ea_kbp1</td><td>The entrainment from above by layer kb+1, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_eakb</td><td>The minimum permissible rate of entrainment, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_eakb</td><td>The maximum permissible rate of entrainment, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ie</td><td>The range of i-indices to work on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_i</td><td>A logical variable indicating which i-points to work on.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cs</td><td>This module's control structure.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ent</td><td>The entrainment rate of the uppermost interior layer, in H. The input value is the first guess.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>The error (locally defined in this routine) associated with the returned solution.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">err_max_eakb0</td><td>The errors (locally defined) associated with min_eakb and max_eakb when ea_kbp1 = 0, returned from a previous call to this routine.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_kb</td><td>The entrainment from below by the uppermost interior layer corresponding to the returned value of Ent, in H.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dfdfm_kb</td><td>The partial derivative of F_kb with ea_kbp1, nondim. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01653">1653</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">References <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01284">determine_dskb()</a>, and <a class="el" href="MOM__error__handler_8F90_source.html#l00073">mom_error_handler::mom_error()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00111">entrainment_diffusive()</a>.</p>
<div class="fragment"><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),            <span class="keywordtype">intent(in)</span>  :: g<span class="comment">        !&lt; The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type),          <span class="keywordtype">intent(in)</span>  :: gv<span class="comment">       !&lt; The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, <span class="keywordtype">intent(in)</span>  :: h_bl<span class="comment">     !&lt; Layer thickness, with the top</span></div><div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;<span class="comment">                                                            !! interior layer at k-index kmb+1, in</span></div><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;<span class="comment">                                                            !! units of m or kg m-2</span></div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;<span class="comment">                                                            !! (abbreviated as H below).</span></div><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, <span class="keywordtype">intent(in)</span>  :: sref<span class="comment">     !&lt; The coordinate reference potential</span></div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;<span class="comment">                                                            !! density, with the value of the</span></div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;<span class="comment">                                                            !! topmost interior layer at layer</span></div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;<span class="comment">                                                            !! kmb+1, in units of kg m-3.</span></div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, <span class="keywordtype">intent(in)</span>  :: ent_bl<span class="comment">   !&lt; The average entrainment upward and</span></div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="comment">                                                            !! downward across each interface around</span></div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;<span class="comment">                                                            !! the buffer layers, in H.</span></div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,         <span class="keywordtype">intent(in)</span>  :: i_dskbp1<span class="comment"> !&lt; The inverse of the difference in</span></div><div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;<span class="comment">                                                            !! reference potential density across</span></div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;<span class="comment">                                                            !! the base of the uppermost interior</span></div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;<span class="comment">                                                            !! layer, in units of m3 kg-1.</span></div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,         <span class="keywordtype">intent(in)</span>  :: dtkd_kb<span class="comment">  !&lt; The diapycnal diffusivity in the top</span></div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;<span class="comment">                                                            !! interior layer times the time step,</span></div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;<span class="comment">                                                            !! in H2.</span></div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,         <span class="keywordtype">intent(in)</span>  :: ea_kbp1<span class="comment">  !&lt; The entrainment from above by layer</span></div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;<span class="comment">                                                            !! kb+1, in H.</span></div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,         <span class="keywordtype">intent(in)</span>  :: min_eakb<span class="comment"> !&lt; The minimum permissible rate of</span></div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;<span class="comment">                                                            !! entrainment, in H.</span></div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,         <span class="keywordtype">intent(in)</span>  :: max_eakb<span class="comment"> !&lt; The maximum permissible rate of</span></div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="comment">                                                            !! entrainment, in H.</span></div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;  <span class="keywordtype">integer</span>,                          <span class="keywordtype">intent(in)</span>  :: kmb</div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;  <span class="keywordtype">integer</span>,                          <span class="keywordtype">intent(in)</span>  :: is, ie<span class="comment">   !&lt; The range of i-indices to work on.</span></div><div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span>,      <span class="keywordtype">intent(in)</span>  :: do_i<span class="comment">     !&lt; A logical variable indicating which</span></div><div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;<span class="comment">                                                            !! i-points to work on.</span></div><div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs),       <span class="keywordtype">pointer</span>     :: cs<span class="comment">       !&lt; This module&#39;s control structure.</span></div><div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,         <span class="keywordtype">intent(inout)</span> :: ent<span class="comment">    !&lt; The entrainment rate of the uppermost</span></div><div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;<span class="comment">                                                            !! interior layer, in H. The input value</span></div><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;<span class="comment">                                                            !! is the first guess.</span></div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">intent(out)</span>, <span class="keywordtype">optional</span> :: error<span class="comment">  !&lt; The error (locally defined in this</span></div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="comment">                                                            !! routine) associated with the returned</span></div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;<span class="comment">                                                            !! solution.</span></div><div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">intent(in)</span>,  <span class="keywordtype">optional</span> :: err_min_eakb0, err_max_eakb0<span class="comment"> !&lt; The errors</span></div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;<span class="comment">                                                            !! (locally defined) associated with</span></div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;<span class="comment">                                                            !! min_eakb and max_eakb when ea_kbp1</span></div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="comment">                                                            !! = 0, returned from a previous call</span></div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;<span class="comment">                                                            !! to this routine.</span></div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">intent(out)</span>, <span class="keywordtype">optional</span> :: f_kb<span class="comment">   !&lt; The entrainment from below by the</span></div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;<span class="comment">                                                            !! uppermost interior layer</span></div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;<span class="comment">                                                            !! corresponding to the returned</span></div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;<span class="comment">                                                            !! value of Ent, in H.</span></div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>, <span class="keywordtype">intent(out)</span>, <span class="keywordtype">optional</span> :: dfdfm_kb<span class="comment"> !&lt; The partial derivative of F_kb with</span></div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;<span class="comment">                                                            !! ea_kbp1, nondim.</span></div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;</div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;<span class="comment">! Arguments: h_bl - Layer thickness, with the top interior layer at k-index</span></div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="comment">!                   kmb+1, in units of m or kg m-2 (abbreviated as H below).</span></div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;<span class="comment">!  (in)      dtKd_kb - The diapycnal diffusivity in the top interior layer times</span></div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;<span class="comment">!                      the time step, in H2.</span></div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="comment">!  (in)      Sref - The coordinate reference potential density, with the</span></div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;<span class="comment">!                   value of the topmost interior layer at layer kmb+1,</span></div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;<span class="comment">!                   in units of kg m-3.</span></div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;<span class="comment">!  (in)      I_dSkbp1 - The inverse of the difference in reference potential</span></div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="comment">!                       density across the base of the uppermost interior layer,</span></div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;<span class="comment">!                       in units of m3 kg-1.</span></div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="comment">!  (in)      Ent_bl - The average entrainment upward and downward across</span></div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="comment">!                     each interface around the buffer layers, in H.</span></div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="comment">!  (in)      ea_kbp1 - The entrainment from above by layer kb+1, in H.</span></div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="comment">!  (in)      min_eakb - The minimum permissible rate of entrainment, in H.</span></div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="comment">!  (in)      max_eakb - The maximum permissible rate of entrainment, in H.</span></div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="comment">!  (in)      is, ie - The range of i-indices to work on.</span></div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;<span class="comment">!  (in)      do_i - A logical variable indicating which i-points to work on.</span></div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="comment">!  (in)      G - The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="comment">!  (in)      GV - The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;<span class="comment">!  (in)      CS - This module&#39;s control structure.</span></div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;<span class="comment">!  (in/out)  Ent - The entrainment rate of the uppermost interior layer, in H.</span></div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;<span class="comment">!                  The input value is the first guess.</span></div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;<span class="comment">!  (out,opt) error - The error (locally defined in this routine) associated with</span></div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;<span class="comment">!                    the returned solution.</span></div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="comment">!  (in,opt)  error_min_eakb0, error_max_eakb0 - The errors (locally defined)</span></div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;<span class="comment">!                    associated with min_eakb and max_eakb when ea_kbp1 = 0,</span></div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;<span class="comment">!                    returned from a previous call to this routine.</span></div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;<span class="comment">!  (out,opt) F_kb - The entrainment from below by the uppermost interior layer</span></div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;<span class="comment">!                   corresponding to the returned value of Ent, in H.</span></div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;<span class="comment">!  (out,out) dFdfm_kb - The partial derivative of F_kb with ea_kbp1, nondim.</span></div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;</div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;<span class="comment">!  This subroutine determines the entrainment from above by the top interior</span></div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;<span class="comment">! layer (labeled kb elsewhere) given an entrainment by the layer below it,</span></div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;<span class="comment">! constrained to be within the provided bounds.</span></div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: &amp;</div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;    ds_kb, &amp;                <span class="comment">!   The coordinate-density difference between the</span></div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;                            <span class="comment">! layer kb and deepest buffer layer, limited to</span></div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;                            <span class="comment">! ensure that it is positive, in kg m-3.</span></div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;    ds_lay, &amp;               <span class="comment">!   The coordinate-density difference across layer</span></div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;                            <span class="comment">! kb, limited to ensure that it is positive and not</span></div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;                            <span class="comment">! too much bigger than dS_kb or dS_kbp1, in kg m-3.</span></div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;    ddskb_de, ddslay_de, &amp;  <span class="comment">! The derivatives of dS_kb and dS_Lay with E,</span></div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;                            <span class="comment">! in units of kg m-3 H-1.</span></div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;    derror_de, &amp;            <span class="comment">! The derivative of err with E, in H.</span></div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;    err, &amp;                  <span class="comment">! The &quot;error&quot; whose zero is being sought, in H2.</span></div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;    e_min, e_max, &amp;         <span class="comment">! The minimum and maximum values of E, in H.</span></div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;    error_mine, error_maxe  <span class="comment">! err when E = E_min or E = E_max, in H2.</span></div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;  <span class="keywordtype">real</span> :: err_est           <span class="comment">! An estimate of what err will be, in H2.</span></div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;  <span class="keywordtype">real</span> :: el                <span class="comment">! 1 or 0, depending on whether increases in E lead</span></div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;                            <span class="comment">! to decreases in the entrainment from below by the</span></div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;                            <span class="comment">! deepest buffer layer.</span></div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;  <span class="keywordtype">real</span> :: fa, fk, fm, fr    <span class="comment">! Temporary variables used to calculate err, in ND, H2, H, H.</span></div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;  <span class="keywordtype">real</span> :: tolerance         <span class="comment">! The tolerance within which E must be converged, in H.</span></div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;  <span class="keywordtype">real</span> :: e_prev            <span class="comment">! The previous value of E, in H.</span></div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: false_position <span class="comment">! If true, the false position</span></div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;                            <span class="comment">! method might be used for the next iteration.</span></div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: redo_i <span class="comment">! If true, more work is needed on this column.</span></div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;  <span class="keywordtype">logical</span> :: do_any</div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">parameter</span> :: large_val = 1.0e30</div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;  <span class="keywordtype">integer</span> :: i, it</div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;  <span class="keywordtype">integer</span>, <span class="keywordtype">parameter</span> :: maxit = 30</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;</div><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;  <span class="keywordflow">if</span> (.not.cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;    <span class="keyword">call </span>mom_error(fatal, <span class="stringliteral">&quot;determine_Ea_kb should not be called &quot;</span>//&amp;</div><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;                           <span class="stringliteral">&quot;unless BULKMIXEDLAYER is defined.&quot;</span>)</div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;  tolerance = gv%m_to_H * cs%Tolerance_Ent</div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;</div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;  <span class="keywordflow">do</span> i=is,ie ; redo_i(i) = do_i(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;</div><div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;  <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;    <span class="comment">! The first guess of Ent was the value from the previous iteration.</span></div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;</div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;    <span class="comment">!   These were previously calculated and provide good limits and estimates</span></div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;    <span class="comment">! of the errors there. By construction the errors increase with R*ea_kbp1.</span></div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;    e_min(i) = min_eakb(i) ; e_max(i) = max_eakb(i)</div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;    error_mine(i) = -large_val ; error_maxe(i) = large_val</div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;    false_position(i) = .true. <span class="comment">! Used to alternate between false_position and</span></div><div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;                               <span class="comment">! bisection when Newton&#39;s method isn&#39;t working.</span></div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(err_min_eakb0)) error_mine(i) = err_min_eakb0(i) - e_min(i) * ea_kbp1(i)</div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(err_max_eakb0)) error_maxe(i) = err_max_eakb0(i) - e_max(i) * ea_kbp1(i)</div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;</div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;    <span class="keywordflow">if</span> ((error_maxe(i) &lt;= 0.0) .or. (error_mine(i) &gt;= 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;      <span class="comment">! The root is not bracketed and one of the limiting values should be used.</span></div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;      <span class="keywordflow">if</span> (error_maxe(i) &lt;= 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;        <span class="comment">! The errors decrease with E*ea_kbp1, so E_max is the best solution.</span></div><div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;        ent(i) = e_max(i) ; err(i) = error_maxe(i)</div><div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;      <span class="keywordflow">else</span>  <span class="comment">! error_minE &gt;= 0 is equivalent to ea_kbp1 = 0.0.</span></div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;        ent(i) = e_min(i) ; err(i) = error_mine(i)</div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;      derror_de(i) = 0.0</div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;      redo_i(i) = .false.</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span>   <span class="comment">! End of i-loop</span></div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;</div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;  <span class="keywordflow">do</span> it = 1,maxit</div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;    do_any = .false. ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (redo_i(i)) do_any = .true. ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;    <span class="keywordflow">if</span> (.not.do_any) <span class="keywordflow">exit</span></div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;    <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, ent, is, ie, kmb, g, gv, .true., ds_kb, &amp;</div><div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;                        ddskb_de, ds_lay, ddslay_de, do_i_in = redo_i)</div><div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (redo_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;      <span class="comment">!  The correct root is bracketed between E_min and E_max.</span></div><div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;      <span class="comment">! Note the following limits:  Ent &gt;= 0 ; fa &gt; 1 ; fk &gt; 0</span></div><div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;      el = 0.0 ; <span class="keywordflow">if</span> (2.0*ent_bl(i,kmb+1) &gt;= ent(i)) el = 1.0</div><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;      fa = (1.0 + el) + ds_kb(i)*i_dskbp1(i)</div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;      fk = dtkd_kb(i) * (ds_lay(i)/ds_kb(i))</div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;      fm = (ea_kbp1(i) - h_bl(i,kmb+1)) + el*2.0*ent_bl(i,kmb+1)</div><div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;      <span class="keywordflow">if</span> (fm &gt; -gv%Angstrom) fm = fm + gv%Angstrom  <span class="comment">! This could be smooth if need be.</span></div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;      err(i) = (fa * ent(i)**2 - fm * ent(i)) - fk</div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;      derror_de(i) = ((2.0*fa + (ddskb_de(i)*i_dskbp1(i))*ent(i))*ent(i) - fm) - &amp;</div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;          dtkd_kb(i) * (ddslay_de(i)*ds_kb(i) - ddskb_de(i)*ds_lay(i))/(ds_kb(i)**2)</div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;</div><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;      <span class="keywordflow">if</span> (err(i) == 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;        redo_i(i) = .false. ; cycle</div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;      <span class="keywordflow">elseif</span> (err(i) &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;        e_max(i) = ent(i) ; error_maxe(i) = err(i)</div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;        e_min(i) = ent(i) ; error_mine(i) = err(i)</div><div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;</div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;      e_prev = ent(i)</div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;      <span class="keywordflow">if</span> ((it == 1) .or. (derror_de(i) &lt;= 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;        <span class="comment">!   Assuming that the coefficients of the quadratic equation are correct</span></div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;        <span class="comment">! will usually give a very good first guess.  Also, if derror_dE &lt; 0.0,</span></div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;        <span class="comment">! R is on the wrong side of the approximate parabola.  In either case,</span></div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;        <span class="comment">! try assuming that the error is approximately a parabola and solve.</span></div><div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;        fr = sqrt(fm**2 + 4.0*fa*fk)</div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;        <span class="keywordflow">if</span> (fm &gt;= 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;          ent(i) = (fm + fr) / (2.0 * fa)</div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;          ent(i) = (2.0 * fk) / (fr - fm)</div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;        <span class="comment">! But make sure that the root stays bracketed, bisecting if needed.</span></div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;        <span class="keywordflow">if</span> ((ent(i) &gt; e_max(i)) .or. (ent(i) &lt; e_min(i))) &amp;</div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;          ent(i) = 0.5*(e_max(i) + e_min(i))</div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;      <span class="keywordflow">elseif</span> (((e_max(i)-ent(i))*derror_de(i) &gt; -err(i)) .and. &amp;</div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;              ((ent(i)-e_min(i))*derror_de(i) &gt; err(i)) ) <span class="keywordflow">then</span></div><div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;        <span class="comment">! Use Newton&#39;s method for the next estimate, provided it will</span></div><div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;        <span class="comment">! remain bracketed between Rmin and Rmax.</span></div><div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;        ent(i) = ent(i) - err(i) / derror_de(i)</div><div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;      <span class="keywordflow">elseif</span> (false_position(i) .and. &amp;</div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;              (error_maxe(i) - error_mine(i) &lt; 0.9*large_val)) <span class="keywordflow">then</span></div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;        <span class="comment">! Use the false postion method if there are decent error estimates.</span></div><div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;        ent(i) = e_min(i) + (e_max(i)-e_min(i)) * &amp;</div><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;                (-error_mine(i)/(error_maxe(i) - error_mine(i)))</div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;        false_position(i) = .false.</div><div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;      <span class="keywordflow">else</span> <span class="comment">! Bisect as a last resort or if the false position method was used last.</span></div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;        ent(i) = 0.5*(e_max(i) + e_min(i))</div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;        false_position(i) = .true.</div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;</div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;      <span class="keywordflow">if</span> (abs(e_prev - ent(i)) &lt; tolerance) <span class="keywordflow">then</span></div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;        err_est = err(i) + (ent(i) - e_prev) * derror_de(i)</div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;        <span class="keywordflow">if</span> ((it &gt; 1) .or. (err_est*err(i) &lt;= 0.0) .or. &amp;</div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;            (abs(err_est) &lt; abs(tolerance*derror_de(i)))) redo_i(i) = .false.</div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;</div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span>   <span class="comment">! End of i-loop</span></div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;<span class="keywordflow">  enddo</span> <span class="comment">! End of iterations to determine Ent(i).</span></div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;</div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;  <span class="comment">! Update the value of dS_kb for consistency with Ent.</span></div><div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(f_kb) .or. <span class="keyword">present</span>(dfdfm_kb)) &amp;</div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;    <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, ent, is, ie, kmb, g, gv, .true., &amp;</div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;                        ds_kb, do_i_in = do_i)</div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;</div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(f_kb)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;    f_kb(i) = ent(i) * (ds_kb(i) * i_dskbp1(i))</div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(error)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;    error(i) = err(i)</div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(dfdfm_kb)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;    <span class="comment">!   derror_dE and ddSkb_dE are _not_ recalculated here, since dFdfm_kb is</span></div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;    <span class="comment">! only used in Newton&#39;s method, and slightly increasing the accuracy of the</span></div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;    <span class="comment">! estimate is unlikely to speed convergence.</span></div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;    <span class="keywordflow">if</span> (derror_de(i) &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;      dfdfm_kb(i) = ((ds_kb(i) + ent(i) * ddskb_de(i)) * i_dskbp1(i)) * &amp;</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;                    (ent(i) / derror_de(i))</div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;    <span class="keywordflow">else</span> <span class="comment">! Use Adcroft&#39;s division by 0 convention.</span></div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;      dfdfm_kb(i) = 0.0</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_a541b3aadc418110f7359b0ae401e4e78_cgraph.svg" width="100%" height="361"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_a541b3aadc418110f7359b0ae401e4e78_icgraph.svg" width="367" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0e71b47abe1e1889f4b687139615ca14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e71b47abe1e1889f4b687139615ca14">&#9670;&nbsp;</a></span>entrain_diffusive_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public mom_entrain_diffusive::entrain_diffusive_end </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), pointer&#160;</td>
          <td class="paramname"><em>CS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l02268">2268</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">Referenced by <a class="el" href="MOM__diabatic__driver_8F90_source.html#l02314">mom_diabatic_driver::diabatic_driver_end()</a>.</p>
<div class="fragment"><div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs), <span class="keywordtype">pointer</span> :: cs</div><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;</div><div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">associated</span>(cs)) <span class="keyword">deallocate</span>(cs)</div><div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_a0e71b47abe1e1889f4b687139615ca14_icgraph.svg" width="355" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a77feea714cc9f7174c7bd07058a5cc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77feea714cc9f7174c7bd07058a5cc73">&#9670;&nbsp;</a></span>entrain_diffusive_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public mom_entrain_diffusive::entrain_diffusive_init </td>
          <td>(</td>
          <td class="paramtype">type(time_type), intent(in)&#160;</td>
          <td class="paramname"><em>Time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(param_file_type), intent(in)&#160;</td>
          <td class="paramname"><em>param_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(diag_ctrl), intent(inout), target&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), pointer&#160;</td>
          <td class="paramname"><em>CS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The current model time.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param_file</td><td>A structure to parse for run-time parameters.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">diag</td><td>A structure that is used to regulate diagnostic output.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cs</td><td>A pointer that is set to point to the control structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l02206">2206</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">References <a class="el" href="MOM__error__handler_8F90_source.html#l00073">mom_error_handler::mom_error()</a>.</p>
<div class="fragment"><div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;  <span class="keywordtype">type</span>(time_type),         <span class="keywordtype">intent(in)</span>    :: time<span class="comment"> !&lt; The current model time.</span></div><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),   <span class="keywordtype">intent(in)</span>    :: g<span class="comment">    !&lt; The ocean&#39;s grid structure.</span></div><div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type), <span class="keywordtype">intent(in)</span>    :: gv<span class="comment">   !&lt; The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;  <span class="keywordtype">type</span>(param_file_type),   <span class="keywordtype">intent(in)</span>    :: param_file<span class="comment"> !&lt; A structure to parse for run-time</span></div><div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;<span class="comment">                                                 !! parameters.</span></div><div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;  <span class="keywordtype">type</span>(diag_ctrl), <span class="keywordtype">target</span>, <span class="keywordtype">intent(inout)</span> :: diag<span class="comment"> !&lt; A structure that is used to regulate diagnostic</span></div><div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;<span class="comment">                                                 !! output.</span></div><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs), <span class="keywordtype">pointer</span>    :: cs<span class="comment">   !&lt; A pointer that is set to point to the control</span></div><div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;<span class="comment">                                                 !! structure.</span></div><div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;<span class="comment">!                 for this module</span></div><div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;<span class="comment">! Arguments: Time - The current model time.</span></div><div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;<span class="comment">!  (in)      G - The ocean&#39;s grid structure.</span></div><div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;<span class="comment">!  (in)      GV - The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;<span class="comment">!  (in)      param_file - A structure indicating the open file to parse for</span></div><div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;<span class="comment">!                         model parameter values.</span></div><div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;<span class="comment">!  (in)      diag - A structure that is used to regulate diagnostic output.</span></div><div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;<span class="comment">!  (in/out)  CS - A pointer that is set to point to the control structure</span></div><div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;<span class="comment">!                 for this module</span></div><div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;  <span class="keywordtype">real</span> :: decay_length, dt, kd</div><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;<span class="comment">! This include declares and sets the variable &quot;version&quot;.</span></div><div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;<span class="preprocessor">#include &quot;version_variable.h&quot;</span></div><div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;<span class="preprocessor"></span>  <span class="keywordtype">character(len=40)</span>  :: mod  = <span class="stringliteral">&quot;MOM_entrain_diffusive&quot;</span> <span class="comment">! This module&#39;s name.</span></div><div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;</div><div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">associated</span>(cs)) <span class="keywordflow">then</span></div><div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;    <span class="keyword">call </span>mom_error(warning, <span class="stringliteral">&quot;entrain_diffusive_init called with an associated &quot;</span>// &amp;</div><div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;                            <span class="stringliteral">&quot;control structure.&quot;</span>)</div><div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;    <span class="keywordflow">return</span></div><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;  <span class="keyword">allocate</span>(cs)</div><div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;</div><div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;  cs%diag =&gt; diag</div><div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;</div><div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;  cs%bulkmixedlayer = (gv%nkml &gt; 0)</div><div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;</div><div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;<span class="comment">! Set default, read and log parameters</span></div><div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;  <span class="keyword">call </span>log_version(param_file, mod, version, <span class="stringliteral">&quot;&quot;</span>)</div><div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;  <span class="keyword">call </span>get_param(param_file, mod, <span class="stringliteral">&quot;CORRECT_DENSITY&quot;</span>, cs%correct_density, &amp;</div><div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;                 <span class="stringliteral">&quot;If true, and USE_EOS is true, the layer densities are \n&quot;</span>//&amp;</div><div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;                 <span class="stringliteral">&quot;restored toward their target values by the diapycnal \n&quot;</span>//&amp;</div><div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;                 <span class="stringliteral">&quot;mixing, as described in Hallberg (MWR, 2000).&quot;</span>, &amp;</div><div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;                 default=.true.)</div><div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;  <span class="keyword">call </span>get_param(param_file, mod, <span class="stringliteral">&quot;MAX_ENT_IT&quot;</span>, cs%max_ent_it, &amp;</div><div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;                 <span class="stringliteral">&quot;The maximum number of iterations that may be used to \n&quot;</span>//&amp;</div><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;                 <span class="stringliteral">&quot;calculate the interior diapycnal entrainment.&quot;</span>, default=5)</div><div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;<span class="comment">! In this module, KD is only used to set the default for TOLERANCE_ENT. (m2 s-1)</span></div><div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;  <span class="keyword">call </span>get_param(param_file, mod, <span class="stringliteral">&quot;KD&quot;</span>, kd, fail_if_missing=.true.)</div><div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;  <span class="keyword">call </span>get_param(param_file, mod, <span class="stringliteral">&quot;DT&quot;</span>, dt, &amp;</div><div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;                 <span class="stringliteral">&quot;The (baroclinic) dynamics time step.&quot;</span>, units = <span class="stringliteral">&quot;s&quot;</span>, &amp;</div><div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;                 fail_if_missing=.true.)</div><div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;<span class="comment">! CS%Tolerance_Ent = MAX(100.0*GV%Angstrom,1.0e-4*sqrt(dt*Kd)) !</span></div><div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;  <span class="keyword">call </span>get_param(param_file, mod, <span class="stringliteral">&quot;TOLERANCE_ENT&quot;</span>, cs%Tolerance_Ent, &amp;</div><div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;                 <span class="stringliteral">&quot;The tolerance with which to solve for entrainment values.&quot;</span>, &amp;</div><div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;                 units=<span class="stringliteral">&quot;m&quot;</span>, default=max(100.0*gv%Angstrom,1.0e-4*sqrt(dt*kd)))</div><div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;</div><div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;  cs%id_Kd = register_diag_field(<span class="stringliteral">&#39;ocean_model&#39;</span>, <span class="stringliteral">&#39;Kd_effective&#39;</span>, diag%axesTL, time, &amp;</div><div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;      <span class="stringliteral">&#39;Diapycnal diffusivity as applied&#39;</span>, <span class="stringliteral">&#39;meter2 second-1&#39;</span>)</div><div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;  cs%id_diff_work = register_diag_field(<span class="stringliteral">&#39;ocean_model&#39;</span>, <span class="stringliteral">&#39;diff_work&#39;</span>, diag%axesTi, time, &amp;</div><div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;      <span class="stringliteral">&#39;Work actually done by diapycnal diffusion across each interface&#39;</span>, <span class="stringliteral">&#39;W m-2&#39;</span>)</div><div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_a77feea714cc9f7174c7bd07058a5cc73_cgraph.svg" width="543" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acf36bae78e6175d37c3de0d61b0ac32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf36bae78e6175d37c3de0d61b0ac32f">&#9670;&nbsp;</a></span>entrainment_diffusive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public mom_entrain_diffusive::entrainment_diffusive </td>
          <td>(</td>
          <td class="paramtype">real, dimension( g %isdb: g %iedb, g %jsd: g %jed, g %ke), intent(in)&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %jsdb: g %jedb, g %ke), intent(in)&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %jsd: g %jed, g %ke), intent(in)&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(thermo_var_ptrs), intent(in)&#160;</td>
          <td class="paramname"><em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(forcing), intent(in)&#160;</td>
          <td class="paramname"><em>fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, intent(in)&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), pointer&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %jsd: g %jed, g %ke), intent(out)&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %jsd: g %jed, g %ke), intent(out)&#160;</td>
          <td class="paramname"><em>eb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( g %isd: g %ied, g %jsd: g %jed), intent(inout), optional&#160;</td>
          <td class="paramname"><em>kb_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %jsd: g %jed, g %ke), intent(in), optional&#160;</td>
          <td class="paramname"><em>Kd_Lay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %jsd: g %jed, g %ke+1), intent(in), optional&#160;</td>
          <td class="paramname"><em>Kd_int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine calculates ea and eb, the rates at which a layer entrains from the layers above and below. The entrainment rates are proportional to the buoyancy flux in a layer and inversely proportional to the density differences between layers. The scheme that is used here is described in detail in Hallberg, Mon. Wea. Rev. 2000. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>The zonal velocity, in m s-1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The meridional velocity, in m s-1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Layer thicknesses, in H (usually m or kg m-2).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tv</td><td>A structure containing pointers to any available thermodynamic fields. Absent fields have NULL ptrs.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluxes</td><td>A structure of surface fluxes that may be used.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The time increment in s.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cs</td><td>The control structure returned by a previous call to entrain_diffusive_init.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ea</td><td>The amount of fluid entrained from the layer</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eb</td><td>The amount of fluid entrained from the layer</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">kb_out</td><td>The index of the lightest layer denser than</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kd_lay</td><td>The diapycnal diffusivity of layers,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kd_int</td><td>The diapycnal diffusivity of interfaces, </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00111">111</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">References <a class="el" href="MOM__EOS_8F90_source.html#l00214">mom_eos::calculate_density_derivs()</a>, <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01284">determine_dskb()</a>, <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01653">determine_ea_kb()</a>, <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01536">f_kb_to_ea_kb()</a>, <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00979">f_to_ent()</a>, <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01890">find_maxf_kb()</a>, <a class="el" href="MOM__error__handler_8F90_source.html#l00049">mom_error_handler::is_root_pe()</a>, <a class="el" href="MOM__error__handler_8F90_source.html#l00073">mom_error_handler::mom_error()</a>, and <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01091">set_ent_bl()</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),      <span class="keywordtype">intent(in)</span>  :: g<span class="comment">  !&lt; The ocean&#39;s grid structure.</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type),    <span class="keywordtype">intent(in)</span>  :: gv<span class="comment"> !&lt; The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZIB_(G),SZJ_(G),SZK_(G))</span>,  &amp;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                              <span class="keywordtype">intent(in)</span>  :: u<span class="comment">  !&lt; The zonal velocity, in m s-1.</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJB_(G),SZK_(G))</span>,  &amp;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                              <span class="keywordtype">intent(in)</span>  :: v<span class="comment">  !&lt; The meridional velocity, in m s-1.</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G))</span>,   &amp;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                              <span class="keywordtype">intent(in)</span>  :: h<span class="comment">  !&lt; Layer thicknesses, in H (usually m or kg m-2).</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="keywordtype">type</span>(thermo_var_ptrs),      <span class="keywordtype">intent(in)</span>  :: tv<span class="comment"> !&lt; A structure containing pointers to any available</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">                                                !! thermodynamic fields. Absent fields have NULL</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">                                                !! ptrs.</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordtype">type</span>(forcing),              <span class="keywordtype">intent(in)</span>  :: fluxes<span class="comment"> !&lt; A structure of surface fluxes that may</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">                                                !! be used.</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="keywordtype">real</span>,                       <span class="keywordtype">intent(in)</span>  :: dt<span class="comment"> !&lt; The time increment in s.</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs), <span class="keywordtype">pointer</span>     :: cs<span class="comment"> !&lt; The control structure returned by a previous</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">                                                !! call to entrain_diffusive_init.</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G))</span>,   &amp;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                              <span class="keywordtype">intent(out)</span> :: ea<span class="comment"> !&lt; The amount of fluid entrained from the layer</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">                                                !! above within this time step, in the same units</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">                                                !! as h, m or kg m-2.</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G))</span>,   &amp;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                              <span class="keywordtype">intent(out)</span> :: eb<span class="comment"> !&lt; The amount of fluid entrained from the layer</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">                                                !! below within this time step, in the same units</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">                                                !! as h, m or kg m-2.</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="keywordtype">integer</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G))</span>,        &amp;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                  <span class="keywordtype">optional</span>, <span class="keywordtype">intent(inout)</span> :: kb_out<span class="comment"> !&lt; The index of the lightest layer denser than</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">                                                !! the buffer layer. At least one of the two</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">                                                !! arguments must be present.</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G))</span>,   &amp;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                  <span class="keywordtype">optional</span>, <span class="keywordtype">intent(in)</span>    :: kd_lay<span class="comment"> !&lt; The diapycnal diffusivity of layers,</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">                                                !! in m2 s-1.</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G)+1)</span>, &amp;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                  <span class="keywordtype">optional</span>, <span class="keywordtype">intent(in)</span>    :: kd_int<span class="comment"> !&lt; The diapycnal diffusivity of interfaces,</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">                                                !! in m2 s-1.</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">!   This subroutine calculates ea and eb, the rates at which a layer</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">! entrains from the layers above and below.  The entrainment rates</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">! are proportional to the buoyancy flux in a layer and inversely</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">! proportional to the density differences between layers.  The</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">! scheme that is used here is described in detail in Hallberg, Mon.</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">! Wea. Rev. 2000.</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">! Arguments: u - Zonal velocity, in m s-1.</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">!  (in)      v - Meridional velocity, in m s-1.</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">!  (in)      h - Layer thickness, in m or kg m-2.</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">!  (in)      fluxes - A structure of surface fluxes that may be used.</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">!  (in)      kb_out - The index of the lightest layer denser than the</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">!                     buffer layers.</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">!  (in)      tv - A structure containing pointers to any available</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">!                 thermodynamic fields. Absent fields have NULL ptrs.</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">!  (in)      dt - The time increment in s.</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">!  (in)      G - The ocean&#39;s grid structure.</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">!  (in)      GV - The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">!  (in)      CS - The control structure returned by a previous call to</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">!                 entrain_diffusive_init.</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">!  (out)     ea - The amount of fluid entrained from the layer above within</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment">!                 this time step, in the same units as h, m or kg m-2.</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">!  (out)     eb - The amount of fluid entrained from the layer below within</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">!                 this time step, in the same units as h, m or kg m-2.</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">!  (out,opt) kb - The index of the lightest layer denser than the buffer layer.</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">! At least one of the two arguments must be present.</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment">!  (in,opt)  Kd_Lay - The diapycnal diffusivity of layers, in m2 s-1.</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">!  (in,opt)  Kd_int - The diapycnal diffusivity of interfaces, in m2 s-1.</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment">! In the comments below, H is used as shorthand for the units of h, m or kg m-2.</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span> :: &amp;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    dtkd    <span class="comment">! The layer diapycnal diffusivity times the time step, translated</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="comment">! into the same unints as h, m2 or kg2 m-4 (i.e. H2).</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G)+1)</span> :: &amp;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    dtkd_int <span class="comment">! The diapycnal diffusivity at the interfaces times the time step,</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="comment">! translated into the same unints as h, m2 or kg2 m-4 (i.e. H2).</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span> :: &amp;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    f, &amp;    <span class="comment">! The density flux through a layer within a time step divided by the</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="comment">! density difference across the interface below the layer, in H.</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    maxf, &amp; <span class="comment">! maxF is the maximum value of F that will not deplete all of the</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            <span class="comment">! layers above or below a layer within a timestep, in H.</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    minf, &amp; <span class="comment">! minF is the minimum flux that should be expected in the absence of</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="comment">! interactions between layers, in H.</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    fprev, &amp;<span class="comment">! The previous estimate of F, in H.</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    dfdfm, &amp;<span class="comment">! The partial derivative of F with respect to changes in F of the</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="comment">! neighboring layers.  Nondimensional.</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    h_guess <span class="comment">! An estimate of the layer thicknesses after entrainment, but</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="comment">! before the entrainments are adjusted to drive the layer</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="comment">! densities toward their target values, in H.</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G)+1)</span> :: &amp;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    ent_bl  <span class="comment">! The average entrainment upward and downward across</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <span class="comment">! each interface around the buffer layers, in H.</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">allocatable</span>, <span class="keywordtype">dimension(:,:,:)</span> :: &amp;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    kd_eff, &amp;     <span class="comment">! The effective diffusivity that actually applies to each</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                  <span class="comment">! layer after the effects of boundary conditions are</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                  <span class="comment">! considered, in m2 s-1.</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    diff_work     <span class="comment">! The work actually done by diffusion across each</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                  <span class="comment">! interface, in W m-2.  Sum vertically for the total work.</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  <span class="keywordtype">real</span> :: hm, fm, fr, fk  <span class="comment">! Work variables with units of H, H, H, and H2.</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  <span class="keywordtype">real</span> :: b1(szi_(g))         <span class="comment">! b1 and c1 are variables used by the</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="keywordtype">real</span> :: c1(szi_(g),szk_(g)) <span class="comment">! tridiagonal solver.</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: &amp;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    htot, &amp;       <span class="comment">! The total thickness above or below a layer in H.</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    rcv, &amp;        <span class="comment">! Value of the coordinate variable (potential density)</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                  <span class="comment">! based on the simulated T and S and P_Ref, kg m-3.</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    pres, &amp;       <span class="comment">! Reference pressure (P_Ref) in Pa.</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    eakb, &amp;       <span class="comment">! The entrainment from above by the layer below the buffer</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                  <span class="comment">! layer (i.e. layer kb), in H.</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    ea_kbp1, &amp;    <span class="comment">! The entrainment from above by layer kb+1, in H.</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    eb_kmb, &amp;     <span class="comment">! The entrainment from below by the deepest buffer layer, in H.</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    ds_kb, &amp;      <span class="comment">! The reference potential density difference across the</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                  <span class="comment">! interface between the buffer layers and layer kb, in kg m-3.</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    ds_anom_lim, &amp;<span class="comment">! The amount by which dS_kb is reduced when limits are</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                  <span class="comment">! applied, in kg m-3.</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    i_dskbp1, &amp;   <span class="comment">! The inverse of the potential density difference across the</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                  <span class="comment">! interface below layer kb, in m3 kg-1.</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    dtkd_kb, &amp;    <span class="comment">! The diapycnal diffusivity in layer kb times the time step,</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                  <span class="comment">! in units of H2.</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    maxf_correct, &amp; <span class="comment">! An amount by which to correct maxF due to excessive</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                  <span class="comment">! surface heat loss, in H.</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    zeros, &amp;      <span class="comment">! An array of all zeros. (Usually used with units of H.)</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    max_eakb, &amp;   <span class="comment">! The maximum value of eakb that might be realized, in H.</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    min_eakb, &amp;   <span class="comment">! The minimum value of eakb that might be realized, in H.</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    err_max_eakb0, &amp; <span class="comment">! The value of error returned by determine_Ea_kb</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    err_min_eakb0, &amp; <span class="comment">! when eakb = min_eakb and max_eakb and ea_kbp1 = 0.</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    err_eakb0, &amp;  <span class="comment">! A value of error returned by determine_Ea_kb.</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    f_kb, &amp;       <span class="comment">! The value of F in layer kb, or equivalently the entrainment</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                  <span class="comment">! from below by layer kb, in H.</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    dfdfm_kb, &amp;   <span class="comment">! The partial derivative of F with fm, nondim. See dFdfm.</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    maxf_kb, &amp;    <span class="comment">! The maximum value of F_kb that might be realized, in H.</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    eakb_maxf, &amp;  <span class="comment">! The value of eakb that gives F_kb=maxF_kb, in H.</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    f_kb_maxent   <span class="comment">! The value of F_kb when eakb = max_eakb, in H.</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span> :: &amp;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    sref, &amp;  <span class="comment">! The reference potential density of the mixed and buffer layers,</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;             <span class="comment">! and of the two lightest interior layers (kb and kb+1) copied</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;             <span class="comment">! into layers kmb+1 and kmb+2, in kg m-3.</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    h_bl     <span class="comment">! The thicknesses of the mixed and buffer layers, and of the two</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;             <span class="comment">! lightest interior layers (kb and kb+1) copied into layers kmb+1</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;             <span class="comment">! and kmb+2, in H.</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span> :: &amp;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    ds_dsp1, &amp;      <span class="comment">! The coordinate variable (sigma-2) difference across an</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                    <span class="comment">! interface divided by the difference across the interface</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                    <span class="comment">! below it. Nondimensional.</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    dsp1_ds, &amp;      <span class="comment">! The inverse coordinate variable (sigma-2) difference</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                    <span class="comment">! across an interface times the difference across the</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                    <span class="comment">! interface above it. Nondimensional.</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    i2p2dsp1_ds, &amp;  <span class="comment">! 1 / (2 + 2 * ds_k+1 / ds_k). Nondimensional.</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    grats           <span class="comment">! 2*(2 + ds_k+1 / ds_k + ds_k / ds_k+1) =</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                    <span class="comment">!       4*ds_Lay*(1/ds_k + 1/ds_k+1). Nondim.</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <span class="keywordtype">real</span> :: drho      <span class="comment">! The change in locally referenced potential density between</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                    <span class="comment">! the layers above and below an interface, in kg m-3.</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  <span class="keywordtype">real</span> :: g_2dt     <span class="comment">! 0.5 * G_Earth / dt, in m s-3.</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: &amp;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    pressure, &amp;      <span class="comment">! The pressure at an interface, in Pa.</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    t_eos, s_eos, &amp;  <span class="comment">! The potential temperature and salinity at which to</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                     <span class="comment">! evaluate dRho_dT and dRho_dS, in degC and PSU.</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    drho_dt, drho_ds <span class="comment">! The partial derivatives of potential density with</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                     <span class="comment">! temperature and salinity, in kg m-3 K-1 and kg m-3 psu-1.</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  <span class="keywordtype">real</span> :: tolerance  <span class="comment">! The tolerance within which E must be converged, in H.</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <span class="keywordtype">real</span> :: angstrom   <span class="comment">! The minimum layer thickness, in H.</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="keywordtype">real</span> :: h_neglect  <span class="comment">! A thickness that is so small it is usually lost</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                     <span class="comment">! in roundoff and can be neglected, in H.</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <span class="keywordtype">real</span> :: f_cor      <span class="comment">! A correction to the amount of F that is used to</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                     <span class="comment">! entrain from the layer above, in H.</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="keywordtype">real</span> :: kd_here    <span class="comment">! The effective diapycnal diffusivity, in H2 s-1.</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="keywordtype">real</span> :: h_avail    <span class="comment">! The thickness that is available for entrainment, in H.</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="keywordtype">real</span> :: ds_kb_eff  <span class="comment">! The value of dS_kb after limiting is taken into account.</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="keywordtype">real</span> :: rho_cor    <span class="comment">! The depth-integrated potential density anomaly that</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                     <span class="comment">! needs to be corrected for, in kg m-2.</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="keywordtype">real</span> :: ea_cor     <span class="comment">! The corrective adjustment to eakb, in H.</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="keywordtype">real</span> :: h1         <span class="comment">! The layer thickness after entrainment through the</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                     <span class="comment">! interface below is taken into account, in H.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keywordtype">real</span> :: idt        <span class="comment">! The inverse of the time step, in s-1.</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="keywordtype">real</span> :: h_to_m, m_to_h  <span class="comment">! Local copies of unit conversion factors.</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <span class="keywordtype">logical</span> :: do_any</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  <span class="keywordtype">logical</span> :: do_i(szi_(g)), did_i(szi_(g)), reiterate, correct_density</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  <span class="keywordtype">integer</span> :: it, i, j, k, is, ie, js, je, nz, k2, kmb</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="keywordtype">integer</span> :: kb(szi_(g))  <span class="comment">! The value of kb in row j.</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  <span class="keywordtype">integer</span> :: kb_min       <span class="comment">! The minimum value of kb in the current j-row.</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="keywordtype">integer</span> :: kb_min_act   <span class="comment">! The minimum active value of kb in the current j-row.</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  <span class="keywordtype">integer</span> :: is1, ie1     <span class="comment">! The minimum and maximum active values of i in the current j-row.</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  is = g%isc ; ie = g%iec ; js = g%jsc ; je = g%jec ; nz = g%ke</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  angstrom = gv%Angstrom</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  h_neglect = gv%H_subroundoff</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  <span class="keywordflow">if</span> (.not. <span class="keyword">associated</span>(cs)) <span class="keyword">call </span>mom_error(fatal, &amp;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;         <span class="stringliteral">&quot;MOM_entrain_diffusive: Module must be initialized before it is used.&quot;</span>)</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="keywordflow">if</span> (.not.(<span class="keyword">present</span>(kd_lay) .or. <span class="keyword">present</span>(kd_int))) <span class="keyword">call </span>mom_error(fatal, &amp;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      <span class="stringliteral">&quot;MOM_entrain_diffusive: Either Kd_Lay or Kd_int must be present in call.&quot;</span>)</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  <span class="keywordflow">if</span> ((.not.cs%bulkmixedlayer .and. .not.<span class="keyword">ASSOCIATED</span>(fluxes%buoy)) .and. &amp;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      (<span class="keyword">ASSOCIATED</span>(fluxes%lprec) .or. <span class="keyword">ASSOCIATED</span>(fluxes%evap) .or. &amp;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;       <span class="keyword">ASSOCIATED</span>(fluxes%sens) .or. <span class="keyword">ASSOCIATED</span>(fluxes%sw))) <span class="keywordflow">then</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordflow">if</span> (is_root_pe()) <span class="keyword">call </span>mom_error(note, <span class="stringliteral">&quot;Calculate_Entrainment: &amp;</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="stringliteral"></span><span class="stringliteral">          &amp;The code to handle evaporation and precipitation without &amp;</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="stringliteral"></span><span class="stringliteral">          &amp;a bulk mixed layer has not been implemented.&quot;</span>)</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="keywordflow">if</span> (is_root_pe()) <span class="keyword">call </span>mom_error(fatal, &amp;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;         <span class="stringliteral">&quot;Either define BULKMIXEDLAYER in MOM_input or use fluxes%buoy &amp;</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="stringliteral"></span><span class="stringliteral">         &amp;and a linear equation of state to drive the model.&quot;</span>)</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  h_to_m = gv%H_to_m ; m_to_h = gv%m_to_H</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  tolerance = m_to_h * cs%Tolerance_Ent</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  g_2dt = 0.5 * gv%g_Earth / dt</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  kmb = gv%nk_rho_varies</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  k2 = max(kmb+1,2) ; kb_min = k2</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  <span class="keywordflow">if</span> (.not. cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    kb(:) = 1</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="comment">! These lines fill in values that are arbitrary, but needed because</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="comment">! they are used to normalize the buoyancy flux in layer nz.</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; ds_dsp1(i,nz) = 2.0 ; dsp1_ds(i,nz) = 0.5 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    kb(:) = 0</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; ds_dsp1(i,nz) = 0.0 ; dsp1_ds(i,nz) = 0.0 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  <span class="keywordflow">if</span> (cs%id_diff_work &gt; 0) <span class="keyword">allocate</span>(diff_work(g%isd:g%ied,g%jsd:g%jed,nz+1))</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  <span class="keywordflow">if</span> (cs%id_Kd &gt; 0)        <span class="keyword">allocate</span>(kd_eff(g%isd:g%ied,g%jsd:g%jed,nz))</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  correct_density = (cs%correct_density .and. <span class="keyword">associated</span>(tv%eqn_of_state))</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  <span class="keywordflow">if</span> (correct_density) <span class="keywordflow">then</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    pres(:) = tv%P_Ref</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    pres(:) = 0.0</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment">!$OMP parallel do default(none) shared(is,ie,js,je,nz,Kd_Lay,G,GV,dt,Kd_int,CS,h,tv, &amp;</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">!$OMP                                  kmb,Angstrom,fluxes,K2,h_neglect,tolerance, &amp;</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">!$OMP                                  ea,eb,correct_density,Kd_eff,diff_work,     &amp;</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment">!$OMP                                  g_2dt, kb_out, m_to_H, H_to_m)              &amp;</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment">!$OMP                     firstprivate(kb,ds_dsp1,dsp1_ds,pres,kb_min)             &amp;</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">!$OMP                          private(dtKd,dtKd_int,do_i,Ent_bl,dtKd_kb,h_bl,     &amp;</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">!$OMP                                  I2p2dsp1_ds,grats,htot,max_eakb,I_dSkbp1,   &amp;</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">!$OMP                                  zeros,maxF_kb,maxF,ea_kbp1,eakb,Sref,       &amp;</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">!$OMP                                  maxF_correct,do_any,                        &amp;</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment">!$OMP                                  err_min_eakb0,err_max_eakb0,eakb_maxF,      &amp;</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">!$OMP                                  min_eakb,err_eakb0,F,minF,hm,fk,F_kb_maxent,&amp;</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">!$OMP                                  F_kb,is1,ie1,kb_min_act,dFdfm_kb,b1,dFdfm,  &amp;</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">!$OMP                                  Fprev,fm,fr,c1,reiterate,eb_kmb,did_i,      &amp;</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">!$OMP                                  h_avail,h_guess,dS_kb,Rcv,F_cor,dS_kb_eff,  &amp;</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">!$OMP                                  Rho_cor,ea_cor,h1,Idt,Kd_here,pressure,     &amp;</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">!$OMP                                  T_eos,S_eos,dRho_dT,dRho_dS,dRho,dS_anom_lim)</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <span class="keywordflow">do</span> j=js,je</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; kb(i) = 1 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(kd_lay)) <span class="keywordflow">then</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;      <span class="keywordflow">do</span> k=1,nz ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        dtkd(i,k) = m_to_h**2 * (dt*kd_lay(i,j,k))</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">present</span>(kd_int)) <span class="keywordflow">then</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">do</span> k=1,nz+1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;          dtkd_int(i,k) = m_to_h**2 * (dt*kd_int(i,j,k))</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="keywordflow">        enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keywordflow">do</span> k=2,nz ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;          dtkd_int(i,k) = m_to_h**2 * (0.5*dt*(kd_lay(i,j,k-1) + kd_lay(i,j,k)))</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="keywordflow">        enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">else</span> <span class="comment">! Kd_int must be present, or there already would have been an error.</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      <span class="keywordflow">do</span> k=1,nz ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        dtkd(i,k) = m_to_h**2 * (0.5*dt*(kd_int(i,j,k)+kd_int(i,j,k+1)))</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      <span class="keywordflow">dO</span> k=1,nz+1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        dtkd_int(i,k) = m_to_h**2 * (dt*kd_int(i,j,k))</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; do_i(i) = (g%mask2dT(i,j) &gt; 0.5) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; ds_dsp1(i,nz) = 0.0 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; dsp1_ds(i,nz) = 0.0 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordflow">do</span> k=2,nz-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;      ds_dsp1(i,k) = gv%g_prime(k) / gv%g_prime(k+1)</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="keywordflow">    enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      <span class="comment">!   This subroutine determines the averaged entrainment across each</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;      <span class="comment">! interface and causes thin and relatively light interior layers to be</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;      <span class="comment">! entrained by the deepest buffer layer.  This also determines kb.</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      <span class="keyword">call </span>set_ent_bl(h, dtkd_int, tv, kb, kmb, do_i, g, gv, cs, j, ent_bl, sref, h_bl)</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        dtkd_kb(i) = 0.0 ; <span class="keywordflow">if</span> (kb(i) &lt; nz) dtkd_kb(i) = dtkd(i,kb(i))</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; ent_bl(i,kmb+1) = 0.0 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">do</span> k=2,nz-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      dsp1_ds(i,k) = 1.0 / ds_dsp1(i,k)</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      i2p2dsp1_ds(i,k) = 0.5/(1.0+dsp1_ds(i,k))</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      grats(i,k) = 2.0*(2.0+(dsp1_ds(i,k)+ds_dsp1(i,k)))</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="keywordflow">    enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">!   Determine the maximum flux, maxF, for each of the isopycnal layers.</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">!   Also determine when the fluxes start entraining</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">! from various buffer or mixed layers, where appropriate.</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      kb_min = nz</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        htot(i) = h(i,j,1) - angstrom</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;      <span class="keywordflow">do</span> k=2,kmb ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        htot(i) = htot(i) + (h(i,j,k) - angstrom)</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        max_eakb(i) = max(ent_bl(i,kmb+1) + 0.5*htot(i), htot(i))</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        i_dskbp1(i) = 1.0 / (sref(i,kmb+2) - sref(i,kmb+1))</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        zeros(i) = 0.0</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;      <span class="comment">!   Find the maximum amount of entrainment from below that the top</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      <span class="comment">! interior layer could exhibit (maxF(i,kb)), approximating that</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;      <span class="comment">! entrainment by (eakb*max(dS_kb/dSkbp1,0)).  eakb is in the range</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;      <span class="comment">! from 0 to max_eakb.</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;      <span class="keyword">call </span>find_maxf_kb(h_bl, sref, ent_bl, i_dskbp1, zeros, max_eakb, kmb, &amp;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                        is, ie, g, gv, cs, maxf_kb, eakb_maxf, do_i, f_kb_maxent)</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (kb(i) &lt;= nz) <span class="keywordflow">then</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        maxf(i,kb(i)) = max(0.0, maxf_kb(i), f_kb_maxent(i))</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        <span class="keywordflow">if</span> ((maxf_kb(i) &gt; f_kb_maxent(i)) .and. (eakb_maxf(i) &gt;= htot(i))) &amp;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;          max_eakb(i) = eakb_maxf(i)</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; ea_kbp1(i) = 0.0 ; eakb(i) = max_eakb(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;      <span class="keyword">call </span>determine_ea_kb(h_bl, dtkd_kb, sref, i_dskbp1, ent_bl, ea_kbp1, &amp;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                           max_eakb, max_eakb, kmb, is, ie, do_i, g, gv, cs, eakb, &amp;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                           error=err_max_eakb0, f_kb=f_kb)</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;      <span class="comment">!   The maximum value of F(kb) between htot and max_eakb determines</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;      <span class="comment">! what maxF(kb+1) should be.</span></div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; min_eakb(i) = min(htot(i), max_eakb(i)) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;      <span class="keyword">call </span>find_maxf_kb(h_bl, sref, ent_bl, i_dskbp1, min_eakb, max_eakb, &amp;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                        kmb, is, ie, g, gv, cs, f_kb_maxent, do_i_in = do_i)</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        <span class="keywordflow">if</span> ((.not.do_i(i)) .or. (err_max_eakb0(i) &gt;= 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;          eakb(i) = 0.0 ; min_eakb(i) = 0.0</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        <span class="keywordflow">else</span> <span class="comment">! If error_max_eakb0 &lt; 0 the buffer layers are always all entrained.</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;          eakb(i) = max_eakb(i) ; min_eakb(i) = max_eakb(i)</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;      <span class="comment">!   Find the amount of entrainment of the buffer layers that would occur</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      <span class="comment">! if there were no entrainment by the deeper interior layers.  Also find</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      <span class="comment">! how much entrainment of the deeper layers would occur.</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      <span class="keyword">call </span>determine_ea_kb(h_bl, dtkd_kb, sref, i_dskbp1, ent_bl, ea_kbp1, &amp;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                           zeros, max_eakb, kmb, is, ie, do_i, g, gv, cs, min_eakb, &amp;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                           error=err_min_eakb0, f_kb=f_kb, err_max_eakb0=err_max_eakb0)</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      <span class="comment">! Error_min_eakb0 should be ~0 unless error_max_eakb0 &lt; 0.</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> ((kb(i)&lt;nz) .and. (kb_min&gt;kb(i))) kb_min = kb(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;      <span class="comment">! Without a bulk mixed layer, surface fluxes are applied in this</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      <span class="comment">! subroutine.  (Otherwise, they are handled in mixedlayer.)</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;      <span class="comment">!   Initially the maximum flux in layer zero is given by the surface</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;      <span class="comment">! buoyancy flux.  It will later be limited if the surface flux is</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;      <span class="comment">! too large.  Here buoy is the surface buoyancy flux.</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        maxf(i,1) = 0.0</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        htot(i) = h(i,j,1) - angstrom</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">ASSOCIATED</span>(fluxes%buoy)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        maxf(i,1) = (dt*fluxes%buoy(i,j)) / gv%g_prime(2)</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment">! The following code calculates the maximum flux, maxF, for the interior</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">! layers.</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keywordflow">do</span> k=kb_min,nz-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;      <span class="keywordflow">if</span> ((k == kb(i)+1) .and. cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        maxf(i,k) = ds_dsp1(i,k)*(f_kb_maxent(i) + htot(i))</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        htot(i) = htot(i) + (h(i,j,k) - angstrom)</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;      <span class="keywordflow">elseif</span> (k &gt; kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        maxf(i,k) = ds_dsp1(i,k)*(maxf(i,k-1) + htot(i))</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        htot(i) = htot(i) + (h(i,j,k) - angstrom)</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="keywordflow">    enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;      maxf(i,nz) = 0.0</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;      <span class="keywordflow">if</span> (.not.cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        maxf_correct(i) = max(0.0, -(maxf(i,nz-1) + htot(i)))</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;      htot(i) = h(i,j,nz) - angstrom</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    <span class="keywordflow">if</span> (.not.cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      do_any = .false. ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (maxf_correct(i) &gt; 0.0) do_any = .true. ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;      <span class="keywordflow">if</span> (do_any) <span class="keywordflow">then</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="keywordflow">do</span> k=nz-1,1,-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;          maxf(i,k) = maxf(i,k) + maxf_correct(i)</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;          maxf_correct(i) = maxf_correct(i) * dsp1_ds(i,k)</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="keywordflow">        enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="keywordflow">do</span> k=nz-1,kb_min,-1 ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;      <span class="keywordflow">if</span> (k&gt;=kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        maxf(i,k) = min(maxf(i,k),dsp1_ds(i,k+1)*maxf(i,k+1) + htot(i))</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        htot(i) = htot(i) + (h(i,j,k) - angstrom)</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        <span class="keywordflow">if</span> ( (k == kb(i)) .and. ((maxf(i,k) &lt; f_kb(i)) .or. &amp;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            (maxf(i,k) &lt; maxf_kb(i)) .and. (eakb_maxf(i) &lt;= max_eakb(i))) ) <span class="keywordflow">then</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;          <span class="comment">!   In this case, too much was being entrained by the topmost interior</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;          <span class="comment">! layer, even with the minimum initial estimate.  The buffer layer</span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;          <span class="comment">! will always entrain the maximum amount.</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;          f_kb(i) = maxf(i,k)</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;          <span class="keywordflow">if</span> ((f_kb(i) &lt;= maxf_kb(i)) .and. (eakb_maxf(i) &lt;= max_eakb(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            eakb(i) = eakb_maxf(i)</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            eakb(i) = max_eakb(i)</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;          <span class="keyword">call </span>f_kb_to_ea_kb(h_bl, sref, ent_bl, i_dskbp1, f_kb, kmb, i, &amp;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                             g, gv, cs, eakb, angstrom)</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;          <span class="keywordflow">if</span> ((eakb(i) &lt; max_eakb(i)) .or. (eakb(i) &lt; min_eakb(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            <span class="keyword">call </span>determine_ea_kb(h_bl, dtkd_kb, sref, i_dskbp1, ent_bl, zeros, &amp;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                                 eakb, eakb, kmb, i, i, do_i, g, gv, cs, eakb, &amp;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;                                 error=err_eakb0)</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="keywordflow">if</span> (eakb(i) &lt; max_eakb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;              max_eakb(i) = eakb(i) ; err_max_eakb0(i) = err_eakb0(i)</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            <span class="keywordflow">if</span> (eakb(i) &lt; min_eakb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;              min_eakb(i) = eakb(i) ; err_min_eakb0(i) = err_eakb0(i)</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    <span class="keywordflow">if</span> (.not.cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        maxf(i,1) = min(maxf(i,1),dsp1_ds(i,2)*maxf(i,2) + htot(i))</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment">!   The following code provides an initial estimate of the flux in</span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment">! each layer, F.  The initial guess for the layer diffusive flux is</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment">! the smaller of a forward discretization or the maximum diffusive</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment">! flux starting from zero thickness in one time step without</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment">! considering adjacent layers.</span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;      f(i,1) = maxf(i,1)</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;      f(i,nz) = maxf(i,nz) ; minf(i,nz) = 0.0</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    <span class="keywordflow">do</span> k=nz-1,k2,-1</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        <span class="keywordflow">if</span> ((k==kb(i)) .and. (do_i(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;          eakb(i) = min_eakb(i)</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;          minf(i,k) = 0.0</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        <span class="keywordflow">elseif</span> ((k&gt;kb(i)) .and. (do_i(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment">!   Here the layer flux is estimated, assuming no entrainment from</span></div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">! the surrounding layers.  The estimate is a forward (steady) flux,</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">! limited by the maximum flux for a layer starting with zero</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">! thickness.  This is often a good guess and leads to few iterations.</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;          hm = h(i,j,k) + h_neglect</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  <span class="comment">!   Note: Tried sqrt((0.5*ds_dsp1(i,k))*dtKd(i,k)) for the second limit,</span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  <span class="comment">! but it usually doesn&#39;t work as well.</span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;          f(i,k) = min(maxf(i,k), sqrt(ds_dsp1(i,k)*dtkd(i,k)), &amp;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                       0.5*(ds_dsp1(i,k)+1.0) * (dtkd(i,k) / hm))</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment">!   Calculate the minimum flux that can be expected if there is no entrainment</span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="comment">! from the neighboring layers.  The 0.9 is used to give used to give a 10%</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="comment">! known error tolerance.</span></div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;          fk = dtkd(i,k) * grats(i,k)</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;          minf(i,k) = min(maxf(i,k), &amp;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                          0.9*(i2p2dsp1_ds(i,k) * fk / (hm + sqrt(hm*hm + fk))))</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;          <span class="keywordflow">if</span> (k==kb(i)) minf(i,k) = 0.0 <span class="comment">! BACKWARD COMPATIBILITY - DELETE LATER?</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;          f(i,k) = 0.0</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;          minf(i,k) = 0.0</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="keywordflow">      enddo</span> <span class="comment">! end of i loop</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="keywordflow">    enddo</span> <span class="comment">! end of k loop</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    <span class="comment">! This is where the fluxes are actually calculated.</span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    is1 = ie+1 ; ie1 = is-1</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span> ; is1 = i ; <span class="keywordflow">exit</span> ;<span class="keywordflow"> endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    <span class="keywordflow">do</span> i=ie,is,-1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span> ; ie1 = i ; <span class="keywordflow">exit</span> ;<span class="keywordflow"> endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;      kb_min_act = nz</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        <span class="keywordflow">if</span> (do_i(i) .and. (kb(i) &lt; kb_min_act)) kb_min_act = kb(i)</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;      <span class="comment">!   Solve for the entrainment rate from above in the topmost interior</span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;      <span class="comment">! layer, eakb, such that</span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;      <span class="comment">!   eakb*dS_implicit = dt*Kd*dS_layer_implicit / h_implicit.</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;      <span class="keywordflow">do</span> i=is1,ie1</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        ea_kbp1(i) = 0.0</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        <span class="keywordflow">if</span> (do_i(i) .and. (kb(i) &lt; nz)) &amp;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;          ea_kbp1(i) = dsp1_ds(i,kb(i)+1)*f(i,kb(i)+1)</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      <span class="keyword">call </span>determine_ea_kb(h_bl, dtkd_kb, sref, i_dskbp1, ent_bl, ea_kbp1, min_eakb, &amp;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                           max_eakb, kmb, is1, ie1, do_i, g, gv, cs, eakb, f_kb=f_kb, &amp;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                           err_max_eakb0=err_max_eakb0, err_min_eakb0=err_min_eakb0, &amp;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                           dfdfm_kb=dfdfm_kb)</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;      kb_min_act = kb_min</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="keywordflow">do</span> it=0,cs%max_ent_it-1</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;      <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;        <span class="keywordflow">if</span> (.not.cs%bulkmixedlayer) f(i,1) = min(f(i,1),maxf(i,1))</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        b1(i) = 1.0</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span> <span class="comment">! end of i loop</span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;     <span class="comment">! F_kb has already been found for this iteration, either above or at</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;     <span class="comment">! the end of the code for the previous iteration.</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;      <span class="keywordflow">do</span> k=kb_min_act,nz-1 ; <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i) .and. (k&gt;=kb(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        <span class="comment">! Calculate the flux in layer k.</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <span class="keywordflow">if</span> (cs%bulkmixedlayer .and. (k==kb(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;          f(i,k) = f_kb(i)</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;          dfdfm(i,k) = dfdfm_kb(i)</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;        <span class="keywordflow">else</span> <span class="comment">! k &gt; kb(i)</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;          fprev(i,k) = f(i,k)</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;          fm = (f(i,k-1) - h(i,j,k)) + dsp1_ds(i,k+1)*f(i,k+1)</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;          fk = grats(i,k)*dtkd(i,k)</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;          fr = sqrt(fm*fm + fk)</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;          <span class="keywordflow">if</span> (fm&gt;=0) <span class="keywordflow">then</span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;            f(i,k) = min(maxf(i,k), i2p2dsp1_ds(i,k) * (fm+fr))</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;            f(i,k) = min(maxf(i,k), i2p2dsp1_ds(i,k) * (fk / (-1.0*fm+fr)))</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;          <span class="keywordflow">if</span> ((f(i,k) &gt;= maxf(i,k)) .or. (fr == 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            dfdfm(i,k) = 0.0</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;            dfdfm(i,k) = i2p2dsp1_ds(i,k) * ((fr + fm) / fr)</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;          <span class="keywordflow">if</span> (k &gt; k2) <span class="keywordflow">then</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            <span class="comment">! This is part of a tridiagonal solver for the actual flux.</span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            c1(i,k) = dfdfm(i,k-1)*(dsp1_ds(i,k)*b1(i))</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            b1(i) = 1.0 / (1.0 - c1(i,k)*dfdfm(i,k))</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;            f(i,k) = min(b1(i)*(f(i,k)-fprev(i,k)) + fprev(i,k), maxf(i,k))</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            <span class="keywordflow">if</span> (f(i,k) &gt;= maxf(i,k)) dfdfm(i,k) = 0.0</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;      <span class="keywordflow">do</span> k=nz-2,kb_min_act,-1 ; <span class="keywordflow">do</span> i=is1,ie1</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        <span class="keywordflow">if</span> (do_i(i) .and. (k &gt; kb(i))) &amp;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;          f(i,k) = min((f(i,k)+c1(i,k+1)*(f(i,k+1)-fprev(i,k+1))),maxf(i,k))</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;      <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        <span class="keywordflow">do</span> i=is1,ie1</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;          <span class="keywordflow">if</span> (do_i(i) .and. (kb(i) &lt; nz)) <span class="keywordflow">then</span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;            <span class="comment">! F will be increased to minF later.</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            ea_kbp1(i) = dsp1_ds(i,kb(i)+1)*max(f(i,kb(i)+1), minf(i,kb(i)+1))</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;            ea_kbp1(i) = 0.0</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="keyword">call </span>determine_ea_kb(h_bl, dtkd_kb, sref, i_dskbp1, ent_bl, ea_kbp1, min_eakb, &amp;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                             max_eakb, kmb, is1, ie1, do_i, g, gv, cs, eakb, f_kb=f_kb, &amp;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                             err_max_eakb0=err_max_eakb0, err_min_eakb0=err_min_eakb0, &amp;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                             dfdfm_kb=dfdfm_kb)</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        <span class="keywordflow">do</span> i=is1,ie1</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;          <span class="keywordflow">if</span> (do_i(i) .and. (kb(i) &lt; nz)) f(i,kb(i)) = f_kb(i)</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment">! Determine whether to do another iteration.</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;      <span class="keywordflow">if</span> (it &lt; cs%max_ent_it-1) <span class="keywordflow">then</span></div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        reiterate = .false.</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;          eb_kmb(i) = max(2.0*ent_bl(i,kmb+1) - eakb(i), 0.0)</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="keywordflow">        endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        <span class="keywordflow">do</span> i=is1,ie1</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;          did_i(i) = do_i(i) ; do_i(i) = .false.</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        <span class="keywordflow">do</span> k=kb_min_act,nz-1 ; <span class="keywordflow">do</span> i=is1,ie1</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;          <span class="keywordflow">if</span> (did_i(i) .and. (k &gt;= kb(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;            <span class="keywordflow">if</span> (f(i,k) &lt; minf(i,k)) <span class="keywordflow">then</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;              f(i,k) = minf(i,k)</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;              do_i(i) = .true. ; reiterate = .true.</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            <span class="keywordflow">elseif</span> (k &gt; kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;              <span class="keywordflow">if</span> ((abs(f(i,k) - fprev(i,k)) &gt; tolerance) .or. &amp;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                  ((h(i,j,k) + ((1.0+dsp1_ds(i,k))*f(i,k) - &amp;</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                   (f(i,k-1) + dsp1_ds(i,k+1)*f(i,k+1)))) &lt; 0.9*angstrom)) <span class="keywordflow">then</span></div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                do_i(i) = .true. ; reiterate = .true.</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="keywordflow">              endif</span></div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            <span class="keywordflow">else</span> <span class="comment">! (k == kb(i))</span></div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="comment">! A more complicated test is required for the layer beneath the buffer layer,</span></div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="comment">! since its flux may be partially used to entrain directly from the mixed layer.</span></div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="comment">! Negative fluxes should not occur with the bulk mixed layer.</span></div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;              <span class="keywordflow">if</span> (h(i,j,k) + ((f(i,k) + eakb(i)) - &amp;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                  (eb_kmb(i) + dsp1_ds(i,k+1)*f(i,k+1))) &lt; 0.9*angstrom) <span class="keywordflow">then</span></div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                do_i(i) = .true. ; reiterate = .true.</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="keywordflow">              endif</span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="keywordflow">        enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;        <span class="keywordflow">if</span> (.not.reiterate) <span class="keywordflow">exit</span></div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="keywordflow">      endif</span> <span class="comment">! end of if (it &lt; CS%max_ent_it-1)</span></div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="keywordflow">    enddo</span> <span class="comment">! end of it loop</span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="comment">! This is the end of the section that might be iterated.</span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    <span class="keywordflow">if</span> (it == (cs%max_ent_it)) <span class="keywordflow">then</span></div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;      <span class="comment">!   Limit the flux so that the layer below is not depleted.</span></div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;      <span class="comment">! This should only be applied to the last iteration.</span></div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;      <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;        f(i,nz-1) = max(f(i,nz-1), min(minf(i,nz-1), 0.0))</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;        <span class="keywordflow">if</span> (kb(i) &gt;= nz-1) <span class="keywordflow">then</span> ; ea_kbp1(i) = 0.0 ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;      <span class="keywordflow">do</span> k=nz-2,kb_min_act,-1 ; <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        <span class="keywordflow">if</span> (k&gt;kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;          f(i,k) = min(max(minf(i,k),f(i,k)), (dsp1_ds(i,k+1)*f(i,k+1) + &amp;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;               max(((f(i,k+1)-dsp1_ds(i,k+2)*f(i,k+2)) + &amp;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                    (h(i,j,k+1) - angstrom)), 0.5*(h(i,j,k+1)-angstrom))))</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;        <span class="keywordflow">elseif</span> (k==kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;          ea_kbp1(i) = dsp1_ds(i,k+1)*f(i,k+1)</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;          h_avail = dsp1_ds(i,k+1)*f(i,k+1) + max(0.5*(h(i,j,k+1)-angstrom), &amp;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;               ((f(i,k+1)-dsp1_ds(i,k+2)*f(i,k+2)) + (h(i,j,k+1) - angstrom)))</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;          <span class="keywordflow">if</span> ((f(i,k) &gt; 0.0) .and. (f(i,k) &gt; h_avail)) <span class="keywordflow">then</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;            f_kb(i) = max(0.0, h_avail)</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;            f(i,k) = f_kb(i)</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;            <span class="keywordflow">if</span> ((f_kb(i) &lt; maxf_kb(i)) .and. (eakb_maxf(i) &lt;= eakb(i))) &amp;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;              eakb(i) = eakb_maxf(i)</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            <span class="keyword">call </span>f_kb_to_ea_kb(h_bl, sref, ent_bl, i_dskbp1, f_kb, kmb, i, &amp;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                               g, gv, cs, eakb)</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;      <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is1,ie1</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        <span class="keywordflow">if</span> (do_i(i) .and. (kb(i) &lt; nz)) <span class="keywordflow">then</span></div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;          h_avail = eakb(i) + max(0.5*(h_bl(i,kmb+1)-angstrom), &amp;</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;                (f_kb(i)-ea_kbp1(i)) + (h_bl(i,kmb+1)-angstrom))</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;          <span class="comment">! Ensure that 0 &lt; eb_kmb &lt; h_avail.</span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;          ent_bl(i,kmb+1) = min(ent_bl(i,kmb+1),0.5*(eakb(i) + h_avail))</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;          eb_kmb(i) = max(2.0*ent_bl(i,kmb+1) - eakb(i), 0.0)</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;     <span class="comment">!  Limit the flux so that the layer above is not depleted.</span></div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;      <span class="keywordflow">do</span> k=kb_min_act+1,nz-1 ; <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        <span class="keywordflow">if</span> ((.not.cs%bulkmixedlayer) .or. (k &gt; kb(i)+1)) <span class="keywordflow">then</span></div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;          f(i,k) = min(f(i,k), ds_dsp1(i,k)*( ((f(i,k-1) + &amp;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;              dsp1_ds(i,k-1)*f(i,k-1)) - f(i,k-2)) + (h(i,j,k-1) - angstrom)))</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;          f(i,k) = max(f(i,k),min(minf(i,k),0.0))</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k == kb(i)+1) <span class="keywordflow">then</span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;          f(i,k) = min(f(i,k), ds_dsp1(i,k)*( ((f(i,k-1) + eakb(i)) - &amp;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;              eb_kmb(i)) + (h(i,j,k-1) - angstrom)))</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;          f(i,k) = max(f(i,k),min(minf(i,k),0.0))</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="keywordflow">    endif</span> <span class="comment">! (it == (CS%max_ent_it))</span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    <span class="keyword">call </span>f_to_ent(f, h, kb, kmb, j, g, gv, cs, dsp1_ds, eakb, ent_bl, ea, eb)</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    <span class="comment">!   Calculate the layer thicknesses after the entrainment to constrain the</span></div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    <span class="comment">! corrective fluxes.</span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    <span class="keywordflow">if</span> (correct_density) <span class="keywordflow">then</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        h_guess(i,1) = (h(i,j,1) - angstrom) + (eb(i,j,1) - ea(i,j,2))</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;        h_guess(i,nz) = (h(i,j,nz) - angstrom) + (ea(i,j,nz) - eb(i,j,nz-1))</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;        <span class="keywordflow">if</span> (h_guess(i,1) &lt; 0.0) h_guess(i,1) = 0.0</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;        <span class="keywordflow">if</span> (h_guess(i,nz) &lt; 0.0) h_guess(i,nz) = 0.0</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;      <span class="keywordflow">do</span> k=2,nz-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        h_guess(i,k) = (h(i,j,k) - angstrom) + ((ea(i,j,k) - eb(i,j,k-1)) + &amp;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                   (eb(i,j,k) - ea(i,j,k+1)))</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;        <span class="keywordflow">if</span> (h_guess(i,k) &lt; 0.0) h_guess(i,k) = 0.0</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;      <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, eakb, is, ie, kmb, g, gv, &amp;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;                            .true., ds_kb, ds_anom_lim=ds_anom_lim)</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        <span class="keywordflow">do</span> k=nz-1,kb_min,-1</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;          <span class="keyword">call </span>calculate_density(tv%T(is:ie,j,k), tv%S(is:ie,j,k), pres(is:ie), &amp;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                                 rcv(is:ie), 1, ie-is+1, tv%eqn_of_state)</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;          <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;            <span class="keywordflow">if</span> ((k&gt;kb(i)) .and. (f(i,k) &gt; 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;              <span class="comment">! Within a time step, a layer may entrain no more than its</span></div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;              <span class="comment">! thickness for correction.  This limitation should apply</span></div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;              <span class="comment">! extremely rarely, but precludes undesirable behavior.</span></div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;              <span class="comment">!  Note: Corrected a sign/logic error &amp; factor of 2 error, and</span></div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;              <span class="comment">!    the layers tracked the target density better, mostly due to</span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;              <span class="comment">!    the factor of 2 error.</span></div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;              f_cor = h(i,j,k) * min(1.0 , max(-ds_dsp1(i,k), &amp;</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                          (gv%Rlay(k) - rcv(i)) / (gv%Rlay(k+1)-gv%Rlay(k))) )</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;              <span class="comment">! Ensure that (1) Entrainments are positive, (2) Corrections in</span></div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;              <span class="comment">! a layer cannot deplete the layer itself (very generously), and</span></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;              <span class="comment">! (3) a layer can take no more than a quarter the mass of its</span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;              <span class="comment">! neighbor.</span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;              <span class="keywordflow">if</span> (f_cor &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                f_cor = min(f_cor, 0.9*f(i,k), ds_dsp1(i,k)*0.5*h_guess(i,k), &amp;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                            0.25*h_guess(i,k+1))</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;              <span class="keywordflow">else</span></div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                f_cor = -min(-f_cor, 0.9*f(i,k), 0.5*h_guess(i,k), &amp;</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                             0.25*ds_dsp1(i,k)*h_guess(i,k-1) )</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<span class="keywordflow">              endif</span></div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;              ea(i,j,k) = ea(i,j,k) - dsp1_ds(i,k)*f_cor</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;              eb(i,j,k) = eb(i,j,k) + f_cor</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((k==kb(i)) .and. (f(i,k) &gt; 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;              <span class="comment">!   Rho_cor is the density anomaly that needs to be corrected,</span></div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;              <span class="comment">! taking into account that the true potential density of the</span></div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;              <span class="comment">! deepest buffer layer is not exactly what is returned as dS_kb.</span></div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;              ds_kb_eff = 2.0*ds_kb(i) - ds_anom_lim(i) <span class="comment">! Could be negative!!!</span></div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;              rho_cor = h(i,j,k) * (gv%Rlay(k)-rcv(i)) + eakb(i)*ds_anom_lim(i)</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;              <span class="comment">! Ensure that  -.9*eakb &lt; ea_cor &lt; .9*eakb</span></div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;              <span class="keywordflow">if</span> (abs(rho_cor) &lt; abs(0.9*eakb(i)*ds_kb_eff)) <span class="keywordflow">then</span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                ea_cor = -rho_cor / ds_kb_eff</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;              <span class="keywordflow">else</span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                ea_cor = sign(0.9*eakb(i),-rho_cor*ds_kb_eff)</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="keywordflow">              endif</span></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;              <span class="keywordflow">if</span> (ea_cor &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                <span class="comment">! Ensure that -F_cor &lt; 0.5*h_guess</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;                ea_cor = min(ea_cor, 0.5*(max_eakb(i) - eakb(i)), &amp;</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;                             0.5*h_guess(i,k) / (ds_kb(i) * i_dskbp1(i)))</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;              <span class="keywordflow">else</span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                <span class="comment">! Ensure that -ea_cor &lt; 0.5*h_guess &amp; F_cor &lt; 0.25*h_guess(k+1)</span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                ea_cor = -min(-ea_cor, 0.5*h_guess(i,k), &amp;</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                              0.25*h_guess(i,k+1) / (ds_kb(i) * i_dskbp1(i)))</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="keywordflow">              endif</span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;              ea(i,j,k) = ea(i,j,k) + ea_cor</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;              eb(i,j,k) = eb(i,j,k) - (ds_kb(i) * i_dskbp1(i)) * ea_cor</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k &lt; kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;              <span class="comment">! Repetative, unless ea(kb) has been corrected.</span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;              ea(i,j,k) = ea(i,j,k+1)</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="keywordflow">          enddo</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;        <span class="keywordflow">do</span> k=kb_min-1,k2,-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;          ea(i,j,k) = ea(i,j,k+1)</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="keywordflow">        enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;        <span class="comment">! Repetative, unless ea(kb) has been corrected.</span></div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        k=kmb</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;        <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;          <span class="comment">! Do not adjust eb through the base of the buffer layers, but it</span></div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;          <span class="comment">! may be necessary to change entrainment from above.</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;          h1 = (h(i,j,k) - angstrom) + (eb(i,j,k) - ea(i,j,k+1))</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;          ea(i,j,k) = max(ent_bl(i,k), ent_bl(i,k)-0.5*h1, -h1)</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;        <span class="keywordflow">do</span> k=kmb-1,2,-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;          <span class="comment">! Determine the entrainment from below for each buffer layer.</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;          eb(i,j,k) = max(2.0*ent_bl(i,k+1) - ea(i,j,k+1), 0.0)</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;          <span class="comment">! Determine the entrainment from above for each buffer layer.</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;          h1 = (h(i,j,k) - angstrom) + (eb(i,j,k) - ea(i,j,k+1))</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;          ea(i,j,k) = max(ent_bl(i,k), ent_bl(i,k)-0.5*h1, -h1)</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="keywordflow">        enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;        <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;          eb(i,j,1) = max(2.0*ent_bl(i,2) - ea(i,j,2), 0.0)</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;      <span class="keywordflow">else</span> <span class="comment">! not bulkmixedlayer</span></div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        <span class="keywordflow">do</span> k=k2,nz-1</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;          <span class="keyword">call </span>calculate_density(tv%T(is:ie,j,k), tv%S(is:ie,j,k), pres(is:ie), &amp;</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                                 rcv(is:ie), 1, ie-is+1, tv%eqn_of_state)</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;          <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (f(i,k) &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;            <span class="comment">! Within a time step, a layer may entrain no more than</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;            <span class="comment">! its thickness for correction.  This limitation should</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;            <span class="comment">! apply extremely rarely, but precludes undesirable</span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;            <span class="comment">! behavior.</span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;            f_cor = h(i,j,k) * min(dsp1_ds(i,k) , max(-1.0, &amp;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                       (gv%Rlay(k) - rcv(i)) / (gv%Rlay(k+1)-gv%Rlay(k))) )</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;            <span class="comment">! Ensure that (1) Entrainments are positive, (2) Corrections in</span></div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            <span class="comment">! a layer cannot deplete the layer itself (very generously), and</span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;            <span class="comment">! (3) a layer can take no more than a quarter the mass of its</span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            <span class="comment">! neighbor.</span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;            <span class="keywordflow">if</span> (f_cor &gt;= 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;              f_cor = min(f_cor, 0.9*f(i,k), 0.5*dsp1_ds(i,k)*h_guess(i,k), &amp;</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                          0.25*h_guess(i,k+1))</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;              f_cor = -min(-f_cor, 0.9*f(i,k), 0.5*h_guess(i,k), &amp;</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;                           0.25*ds_dsp1(i,k)*h_guess(i,k-1) )</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;            ea(i,j,k) = ea(i,j,k) - dsp1_ds(i,k)*f_cor</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;            eb(i,j,k) = eb(i,j,k) + f_cor</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="keywordflow">          endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="keywordflow">    endif</span>   <span class="comment">! correct_density</span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    <span class="keywordflow">if</span> (cs%id_Kd &gt; 0) <span class="keywordflow">then</span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;      idt = 1.0 / dt</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;      <span class="keywordflow">do</span> k=2,nz-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;        <span class="keywordflow">if</span> (k&lt;kb(i)) <span class="keywordflow">then</span> ; kd_here = 0.0 ; <span class="keywordflow">else</span></div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;          kd_here = f(i,k) * ( h(i,j,k) + ((ea(i,j,k) - eb(i,j,k-1)) + &amp;</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;              (eb(i,j,k) - ea(i,j,k+1))) ) / (i2p2dsp1_ds(i,k) * grats(i,k))</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        kd_eff(i,j,k) = h_to_m**2 * (max(dtkd(i,k),kd_here)*idt)</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="keywordflow">      enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;        kd_eff(i,j,1) = h_to_m**2 * (dtkd(i,1)*idt)</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;        kd_eff(i,j,nz) = h_to_m**2 * (dtkd(i,nz)*idt)</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="keywordflow">if</span> (cs%id_diff_work &gt; 0) <span class="keywordflow">then</span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; diff_work(i,j,1) = 0.0 ; diff_work(i,j,nz+1) = 0.0 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">associated</span>(tv%eqn_of_state)) <span class="keywordflow">then</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">associated</span>(fluxes%p_surf)) <span class="keywordflow">then</span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;          <span class="keywordflow">do</span> i=is,ie ; pressure(i) = fluxes%p_surf(i,j) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;          <span class="keywordflow">do</span> i=is,ie ; pressure(i) = 0.0 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;        <span class="keywordflow">do</span> k=2,nz</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;          <span class="keywordflow">do</span> i=is,ie ; pressure(i) = pressure(i) + gv%H_to_Pa*h(i,j,k-1) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;          <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            <span class="keywordflow">if</span> (k==kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;              t_eos(i) = 0.5*(tv%T(i,j,kmb) + tv%T(i,j,k))</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;              s_eos(i) = 0.5*(tv%S(i,j,kmb) + tv%S(i,j,k))</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;              t_eos(i) = 0.5*(tv%T(i,j,k-1) + tv%T(i,j,k))</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;              s_eos(i) = 0.5*(tv%S(i,j,k-1) + tv%S(i,j,k))</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="keywordflow">          enddo</span></div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;          <span class="keyword">call </span>calculate_density_derivs(t_eos, s_eos, pressure, &amp;</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;                  drho_dt, drho_ds, is, ie-is+1, tv%eqn_of_state)</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;          <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            <span class="keywordflow">if</span> ((k&gt;kmb) .and. (k&lt;kb(i))) <span class="keywordflow">then</span> ; diff_work(i,j,k) = 0.0</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;              <span class="keywordflow">if</span> (k==kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;                drho = drho_dt(i) * (tv%T(i,j,k)-tv%T(i,j,kmb)) + &amp;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;                       drho_ds(i) * (tv%S(i,j,k)-tv%S(i,j,kmb))</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;              <span class="keywordflow">else</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;                drho = drho_dt(i) * (tv%T(i,j,k)-tv%T(i,j,k-1)) + &amp;</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;                       drho_ds(i) * (tv%S(i,j,k)-tv%S(i,j,k-1))</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;<span class="keywordflow">              endif</span></div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;              diff_work(i,j,k) = g_2dt * drho * &amp;</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                   (ea(i,j,k) * (h(i,j,k) + ea(i,j,k)) + &amp;</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;                    eb(i,j,k-1)*(h(i,j,k-1) + eb(i,j,k-1)))</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="keywordflow">          enddo</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="keywordflow">        enddo</span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;        <span class="keywordflow">do</span> k=2,nz ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;          diff_work(i,j,k) = g_2dt * (gv%Rlay(k)-gv%Rlay(k-1)) * &amp;</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;               (ea(i,j,k) * (h(i,j,k) + ea(i,j,k)) + &amp;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                eb(i,j,k-1)*(h(i,j,k-1) + eb(i,j,k-1)))</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="keywordflow">        enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">present</span>(kb_out)) <span class="keywordflow">then</span></div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; kb_out(i,j) = kb(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;<span class="keywordflow">  enddo</span> <span class="comment">! end of j loop</span></div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="comment">! Offer diagnostic fields for averaging.</span></div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;  <span class="keywordflow">if</span> (cs%id_Kd &gt; 0) <span class="keyword">call </span>post_data(cs%id_Kd, kd_eff, cs%diag)</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;  <span class="keywordflow">if</span> (cs%id_Kd &gt; 0) <span class="keyword">deallocate</span>(kd_eff)</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;  <span class="keywordflow">if</span> (cs%id_diff_work &gt; 0) <span class="keyword">call </span>post_data(cs%id_diff_work, diff_work, cs%diag)</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;  <span class="keywordflow">if</span> (cs%id_diff_work &gt; 0) <span class="keyword">deallocate</span>(diff_work)</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_acf36bae78e6175d37c3de0d61b0ac32f_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="adce1b1ba57f5245f1eda57e7a254d4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce1b1ba57f5245f1eda57e7a254d4df">&#9670;&nbsp;</a></span>f_kb_to_ea_kb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mom_entrain_diffusive::f_kb_to_ea_kb </td>
          <td>(</td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>h_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>Sref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>Ent_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>I_dSkbp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>F_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>kmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), pointer&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(inout)&#160;</td>
          <td class="paramname"><em>ea_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, intent(in), optional&#160;</td>
          <td class="paramname"><em>tol_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01536">1536</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">References <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01284">determine_dskb()</a>, and <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01890">find_maxf_kb()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00111">entrainment_diffusive()</a>.</p>
<div class="fragment"><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),         <span class="keywordtype">intent(in)</span>    :: g<span class="comment">    !&lt; The ocean&#39;s grid structure</span></div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type),       <span class="keywordtype">intent(in)</span>    :: gv<span class="comment">   !&lt; The ocean&#39;s vertical grid structure</span></div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, <span class="keywordtype">intent(in)</span> :: h_bl, sref, ent_bl</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,      <span class="keywordtype">intent(in)</span>    :: i_dskbp1, f_kb</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;  <span class="keywordtype">integer</span>,                       <span class="keywordtype">intent(in)</span>    :: kmb, i</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs),    <span class="keywordtype">pointer</span>       :: cs</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,      <span class="keywordtype">intent(inout)</span> :: ea_kb</div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;  <span class="keywordtype">real</span>,                <span class="keywordtype">optional</span>, <span class="keywordtype">intent(in)</span>    :: tol_in</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;  <span class="comment">!   Given an entrainment from below for layer kb, determine a consistent</span></div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;  <span class="comment">! entrainment from above, such that dSkb * ea_kb = dSkbp1 * F_kb.  The input</span></div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;  <span class="comment">! value of ea_kb is both the maximum value that can be obtained and the first</span></div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;  <span class="comment">! guess of the iterations.  Also, make sure that ea_kb is an under-estimate</span></div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;  <span class="keywordtype">real</span> :: max_ea, min_ea</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;  <span class="keywordtype">real</span> :: err, err_min, err_max</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;  <span class="keywordtype">real</span> :: derr_dea</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;  <span class="keywordtype">real</span> :: val, tolerance, tol1</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;  <span class="keywordtype">real</span> :: ea_prev</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;  <span class="keywordtype">real</span> :: ds_kbp1</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;  <span class="keywordtype">logical</span> :: bisect_next, newton</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: ds_kb</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: maxf, ent_maxf, zeros</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: ddskb_de</div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;  <span class="keywordtype">integer</span> :: it</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;  <span class="keywordtype">integer</span>, <span class="keywordtype">parameter</span> :: maxit = 30</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;  ds_kbp1 = sref(i,kmb+2) - sref(i,kmb+1)</div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;  max_ea = ea_kb(i) ; min_ea = 0.0</div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;  val = ds_kbp1 * f_kb(i)</div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;  err_min = -val</div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;</div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;  tolerance = gv%m_to_H * cs%Tolerance_Ent</div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(tol_in)) tolerance = tol_in</div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;  bisect_next = .true.</div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;</div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;  <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, ea_kb, i, i, kmb, g, gv, .true., &amp;</div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;                      ds_kb, ddskb_de)</div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;</div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;  err = ds_kb(i) * ea_kb(i) - val</div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;  derr_dea = ds_kb(i) + ddskb_de(i) * ea_kb(i)</div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;  <span class="comment">! Return if Newton&#39;s method on the first guess would give a tolerably small</span></div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;  <span class="comment">! change in the value of ea_kb.</span></div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;  <span class="keywordflow">if</span> ((err &lt;= 0.0) .and. (abs(err) &lt;= tolerance*abs(derr_dea))) <span class="keywordflow">return</span></div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;</div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;  <span class="keywordflow">if</span> (err == 0.0) <span class="keywordflow">then</span> ; <span class="keywordflow">return</span> <span class="comment">! The exact solution on the first guess...</span></div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;  <span class="keywordflow">elseif</span> (err &gt; 0.0) <span class="keywordflow">then</span> <span class="comment">! The root is properly bracketed.</span></div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;    max_ea = ea_kb(i) ; err_max = err</div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;    <span class="comment">!   Use Newton&#39;s method (if it stays bounded) or the false position method</span></div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;    <span class="comment">! to find the next value.</span></div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;    <span class="keywordflow">if</span> ((derr_dea &gt; 0.0) .and. (derr_dea*(ea_kb(i) - min_ea) &gt; err) .and. &amp;</div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;        (derr_dea*(max_ea - ea_kb(i)) &gt; -1.0*err)) <span class="keywordflow">then</span></div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;      ea_kb(i) = ea_kb(i) - err / derr_dea</div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;    <span class="keywordflow">else</span> <span class="comment">! Use the bisection for the next guess.</span></div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;      ea_kb(i) = 0.5*(max_ea+min_ea)</div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;    <span class="comment">!   Try to bracket the root first.  If unable to bracket the root, return</span></div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;    <span class="comment">! the maximum.</span></div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;    zeros(i) = 0.0</div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    <span class="keyword">call </span>find_maxf_kb(h_bl, sref, ent_bl, i_dskbp1, zeros, ea_kb, &amp;</div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;                      kmb, i, i, g, gv, cs, maxf, ent_maxf, f_thresh = f_kb)</div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;    err_max = ds_kbp1 * maxf(i) - val</div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;    <span class="comment">! If err_max is negative, there is no good solution, so use the maximum</span></div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;    <span class="comment">! value of F in the valid range.</span></div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;    <span class="keywordflow">if</span> (err_max &lt;= 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;      ea_kb(i) = ent_maxf(i) ; <span class="keywordflow">return</span></div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;      max_ea = ent_maxf(i)</div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;      ea_kb(i) = 0.5*(max_ea+min_ea) <span class="comment">! Use bisection for the next guess.</span></div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;</div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;  <span class="comment">! Exit if the range between max_ea and min_ea already acceptable.</span></div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;  <span class="comment">! if (abs(max_ea - min_ea) &lt; 0.1*tolerance) return</span></div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;</div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;  <span class="keywordflow">do</span> it = 1, maxit</div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;    <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, ea_kb, i, i, kmb, g, gv, .true., &amp;</div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;                        ds_kb, ddskb_de)</div><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;</div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;    err = ds_kb(i) * ea_kb(i) - val</div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;    derr_dea = ds_kb(i) + ddskb_de(i) * ea_kb(i)</div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;</div><div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;    ea_prev = ea_kb(i)</div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;    <span class="comment">! Use Newton&#39;s method or the false position method to find the next value.</span></div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;    newton = .false.</div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;    <span class="keywordflow">if</span> (err &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;      max_ea = ea_kb(i) ; err_max = err</div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;      <span class="keywordflow">if</span> ((derr_dea &gt; 0.0) .and. (derr_dea*(ea_kb(i)-min_ea) &gt; err)) newton = .true.</div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;      min_ea = ea_kb(i) ; err_min = err</div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;      <span class="keywordflow">if</span> ((derr_dea &gt; 0.0) .and. (derr_dea*(ea_kb(i)-max_ea) &lt; err)) newton = .true.</div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;</div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;    <span class="keywordflow">if</span> (newton) <span class="keywordflow">then</span></div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;      ea_kb(i) = ea_kb(i) - err / derr_dea</div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;    <span class="keywordflow">elseif</span> (bisect_next) <span class="keywordflow">then</span> <span class="comment">! Use bisection to reduce the range.</span></div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;      ea_kb(i) = 0.5*(max_ea+min_ea)</div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;      bisect_next = .false.</div><div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;    <span class="keywordflow">else</span>  <span class="comment">! Use the false-position method for the next guess.</span></div><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;      ea_kb(i) = min_ea + (max_ea-min_ea) * (err_min/(err_min - err_max))</div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;      bisect_next = .true.</div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;</div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;    tol1 = tolerance ; <span class="keywordflow">if</span> (err &gt; 0.0) tol1 = 0.099*tolerance</div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;    <span class="keywordflow">if</span> (ds_kb(i) &lt;= ds_kbp1) <span class="keywordflow">then</span></div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;      <span class="keywordflow">if</span> (abs(ea_kb(i) - ea_prev) &lt;= tol1) <span class="keywordflow">return</span></div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;      <span class="keywordflow">if</span> (ds_kbp1*abs(ea_kb(i) - ea_prev) &lt;= ds_kb(i)*tol1) <span class="keywordflow">return</span></div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_adce1b1ba57f5245f1eda57e7a254d4df_cgraph.svg" width="100%" height="361"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_adce1b1ba57f5245f1eda57e7a254d4df_icgraph.svg" width="367" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a13bbe9f35e3198470100375d9d016b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bbe9f35e3198470100375d9d016b7a">&#9670;&nbsp;</a></span>f_to_ent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mom_entrain_diffusive::f_to_ent </td>
          <td>(</td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szj_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>kmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), intent(in)&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>dsp1_ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>eakb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>Ent_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szj_(g),szk_(g)), intent(inout)&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szj_(g),szk_(g)), intent(inout)&#160;</td>
          <td class="paramname"><em>eb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension(szi_(g)), intent(in), optional&#160;</td>
          <td class="paramname"><em>do_i_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subroutine calculates the actual entrainments (ea and eb) and the amount of surface forcing that is applied to each layer if there is no bulk mixed layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Layer thicknesses, in H (usually m or kg m-2) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00979">979</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">Referenced by <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00111">entrainment_diffusive()</a>.</p>
<div class="fragment"><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),                    <span class="keywordtype">intent(in)</span>    :: g<span class="comment">    !&lt; The ocean&#39;s grid structure</span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type),                  <span class="keywordtype">intent(in)</span>    :: gv<span class="comment">   !&lt; The ocean&#39;s vertical grid structure</span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>,         <span class="keywordtype">intent(in)</span>    :: f</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G))</span>, <span class="keywordtype">intent(in)</span>    :: h<span class="comment">    !&lt; Layer thicknesses, in H (usually m or kg m-2)</span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;  <span class="keywordtype">integer</span>, <span class="keywordtype">dimension(SZI_(G))</span>,              <span class="keywordtype">intent(in)</span>    :: kb</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;  <span class="keywordtype">integer</span>,                                  <span class="keywordtype">intent(in)</span>    :: kmb, j</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs),               <span class="keywordtype">intent(in)</span>    :: cs</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>,         <span class="keywordtype">intent(in)</span>    :: dsp1_ds</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,                 <span class="keywordtype">intent(in)</span>    :: eakb</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>,         <span class="keywordtype">intent(in)</span>    :: ent_bl</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G))</span>, <span class="keywordtype">intent(inout)</span> :: ea, eb</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span>,    <span class="keywordtype">optional</span>, <span class="keywordtype">intent(in)</span>    :: do_i_in</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="comment">!   This subroutine calculates the actual entrainments (ea and eb) and the</span></div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="comment">! amount of surface forcing that is applied to each layer if there is no bulk</span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="comment">! mixed layer.</span></div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;  <span class="keywordtype">real</span> :: h1        <span class="comment">! The thickness in excess of the minimum that will remain</span></div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                    <span class="comment">! after exchange with the layer below, in m or kg m-2.</span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;  <span class="keywordtype">logical</span> :: do_i(szi_(g))</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;  <span class="keywordtype">integer</span> :: i, k, is, ie, nz</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;  is = g%isc ; ie = g%iec ; nz = g%ke</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(do_i_in)) <span class="keywordflow">then</span></div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; do_i(i) = do_i_in(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;    <span class="keywordflow">do</span> i=g%isc,g%iec ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;      is = i ; <span class="keywordflow">exit</span></div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;    <span class="keywordflow">do</span> i=g%iec,g%isc,-1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;      ie = i ; <span class="keywordflow">exit</span></div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; do_i(i) = .true. ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;  <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;    ea(i,j,nz) = 0.0 ; eb(i,j,nz) = 0.0</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;  <span class="keywordflow">if</span> (cs%bulkmixedlayer) <span class="keywordflow">then</span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;      eb(i,j,kmb) = max(2.0*ent_bl(i,kmb+1) - eakb(i), 0.0)</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="keywordflow">do</span> k=nz-1,kmb+1,-1 ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;      <span class="keywordflow">if</span> (k &gt; kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;        <span class="comment">! With a bulk mixed layer, surface buoyancy fluxes are applied</span></div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;        <span class="comment">! elsewhere, so F should always be nonnegative.</span></div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;        ea(i,j,k) = dsp1_ds(i,k)*f(i,k)</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;        eb(i,j,k) = f(i,k)</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k == kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;        ea(i,j,k) = eakb(i)</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;        eb(i,j,k) = f(i,k)</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;      <span class="keywordflow">elseif</span> (k == kb(i)-1) <span class="keywordflow">then</span></div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;        ea(i,j,k) = ea(i,j,k+1)</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;        eb(i,j,k) = eb(i,j,kmb)</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;        ea(i,j,k) = ea(i,j,k+1)</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;        <span class="comment">!   Add the entrainment of the thin interior layers to eb going</span></div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;        <span class="comment">! up into the buffer layer.</span></div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;        eb(i,j,k) = eb(i,j,k+1) + max(0.0, h(i,j,k+1) - gv%Angstrom)</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;    k = kmb</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;      <span class="comment">! Adjust the previously calculated entrainment from below by the deepest</span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;      <span class="comment">! buffer layer to account for entrainment of thin interior layers .</span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;      <span class="keywordflow">if</span> (kb(i) &gt; kmb+1) &amp;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;        eb(i,j,k) = eb(i,j,k+1) + max(0.0, h(i,j,k+1) - gv%Angstrom)</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;      <span class="comment">! Determine the entrainment from above for each buffer layer.</span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;      h1 = (h(i,j,k) - gv%Angstrom) + (eb(i,j,k) - ea(i,j,k+1))</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;      ea(i,j,k) = max(ent_bl(i,k), ent_bl(i,k)-0.5*h1, -h1)</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;    <span class="keywordflow">do</span> k=kmb-1,2,-1 ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;      <span class="comment">! Determine the entrainment from below for each buffer layer.</span></div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;      eb(i,j,k) = max(2.0*ent_bl(i,k+1) - ea(i,j,k+1), 0.0)</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;      <span class="comment">! Determine the entrainment from above for each buffer layer.</span></div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;      h1 = (h(i,j,k) - gv%Angstrom) + (eb(i,j,k) - ea(i,j,k+1))</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;      ea(i,j,k) = max(ent_bl(i,k), ent_bl(i,k)-0.5*h1, -h1)</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="comment">!       if (h1 &gt;= 0.0) then ;                     ea(i,j,k) = Ent_bl(i,K)</span></div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;<span class="comment">!       elseif (Ent_bl(i,K)+0.5*h1 &gt;= 0.0) then ; ea(i,j,k) = Ent_bl(i,K)-0.5*h1</span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;<span class="comment">!       else ;                                    ea(i,j,k) = -h1 ; endif</span></div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;      eb(i,j,1) = max(2.0*ent_bl(i,2) - ea(i,j,2), 0.0)</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;      ea(i,j,1) = 0.0</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;  <span class="keywordflow">else</span>                                          <span class="comment">! not BULKMIXEDLAYER</span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;    <span class="comment">! Calculate the entrainment by each layer from above and below.</span></div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;    <span class="comment">! Entrainment is always positive, but F may be negative due to</span></div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    <span class="comment">! surface buoyancy fluxes.</span></div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;      ea(i,j,1) = 0.0 ; eb(i,j,1) = max(f(i,1),0.0)</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;      ea(i,j,2) = dsp1_ds(i,2)*f(i,2) - min(f(i,1),0.0)</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    <span class="keywordflow">do</span> k=2,nz-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;      eb(i,j,k) = max(f(i,k),0.0)</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;      ea(i,j,k+1) = dsp1_ds(i,k+1)*f(i,k+1) - (f(i,k)-eb(i,j,k))</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;      <span class="keywordflow">if</span> (ea(i,j,k+1) &lt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;        eb(i,j,k) = eb(i,j,k) - ea(i,j,k+1)</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;        ea(i,j,k+1) = 0.0</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;<span class="keywordflow">    enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;<span class="keywordflow">  endif</span>                                         <span class="comment">! end BULKMIXEDLAYER</span></div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_a13bbe9f35e3198470100375d9d016b7a_icgraph.svg" width="367" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae45dbf976314c3a9e278ebcebedab109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45dbf976314c3a9e278ebcebedab109">&#9670;&nbsp;</a></span>find_maxf_kb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mom_entrain_diffusive::find_maxf_kb </td>
          <td>(</td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>h_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>Sref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>Ent_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>I_dSkbp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>min_ent_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>max_ent_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>kmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), pointer&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(out)&#160;</td>
          <td class="paramname"><em>maxF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(out), optional&#160;</td>
          <td class="paramname"><em>ent_maxF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension( g %isd: g %ied), intent(in), optional&#160;</td>
          <td class="paramname"><em>do_i_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(out), optional&#160;</td>
          <td class="paramname"><em>F_lim_maxent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied), intent(in), optional&#160;</td>
          <td class="paramname"><em>F_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_bl</td><td>Layer thickness, in m or kg m-2</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sref</td><td>Reference potential density (in kg m-3?).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ent_bl</td><td>The average entrainment upward and</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_dskbp1</td><td>The inverse of the difference in reference potential density across the base of the uppermost interior layer, in units of m3 kg-1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_ent_in</td><td>The minimum value of ent to search, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_ent_in</td><td>The maximum value of ent to search, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ie</td><td>The range of i-indices to work on.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cs</td><td>This module's control structure.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxf</td><td>The maximum value of F = ent*ds_kb*I_dSkbp1 found in the range min_ent &lt; ent &lt; max_ent, in H.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ent_maxf</td><td>The value of ent at that maximum, in H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_i_in</td><td>A logical array indicating which columns</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_lim_maxent</td><td>If present, do not apply the limit in</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_thresh</td><td>If F_thresh is present, return the first </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01890">1890</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">References <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01284">determine_dskb()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00111">entrainment_diffusive()</a>, and <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01536">f_kb_to_ea_kb()</a>.</p>
<div class="fragment"><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),        <span class="keywordtype">intent(in)</span>  :: g<span class="comment">        !&lt; The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type),      <span class="keywordtype">intent(in)</span>  :: gv<span class="comment">       !&lt; The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, &amp;</div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;                                <span class="keywordtype">intent(in)</span>  :: h_bl<span class="comment">     !&lt; Layer thickness, in m or kg m-2</span></div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;<span class="comment">                                                        !! (abbreviated as H below).</span></div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, &amp;</div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;                                 <span class="keywordtype">intent(in)</span> :: sref<span class="comment">     !&lt; Reference potential density (in kg m-3?).</span></div><div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, &amp;</div><div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;                                <span class="keywordtype">intent(in)</span>  :: ent_bl<span class="comment">   !&lt; The average entrainment upward and</span></div><div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;<span class="comment">                                                        !! downward across each interface around</span></div><div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;<span class="comment">                                                        !! the buffer layers, in H.</span></div><div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,     <span class="keywordtype">intent(in)</span>  :: i_dskbp1<span class="comment"> !&lt; The inverse of the difference in</span></div><div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;<span class="comment">                                                        !! reference potential density across the</span></div><div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;<span class="comment">                                                        !! base of the uppermost interior layer,</span></div><div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;<span class="comment">                                                        !! in units of m3 kg-1.</span></div><div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,     <span class="keywordtype">intent(in)</span>  :: min_ent_in<span class="comment"> !&lt; The minimum value of ent to search,</span></div><div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;<span class="comment">                                                        !! in H.</span></div><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,     <span class="keywordtype">intent(in)</span>  :: max_ent_in<span class="comment"> !&lt; The maximum value of ent to search,</span></div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;<span class="comment">                                                        !! in H.</span></div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;  <span class="keywordtype">integer</span>,                      <span class="keywordtype">intent(in)</span>  :: kmb</div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;  <span class="keywordtype">integer</span>,                      <span class="keywordtype">intent(in)</span>  :: is, ie<span class="comment">   !&lt; The range of i-indices to work on.</span></div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs),   <span class="keywordtype">pointer</span>     :: cs<span class="comment">       !&lt; This module&#39;s control structure.</span></div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,     <span class="keywordtype">intent(out)</span> :: maxf<span class="comment">     !&lt; The maximum value of F</span></div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;<span class="comment">                                                        !! = ent*ds_kb*I_dSkbp1 found in the range</span></div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;<span class="comment">                                                        !! min_ent &lt; ent &lt; max_ent, in H.</span></div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,     <span class="keywordtype">intent(out)</span>, &amp;</div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;                                   <span class="keywordtype">optional</span> :: ent_maxf<span class="comment"> !&lt; The value of ent at that maximum, in H.</span></div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span>,  <span class="keywordtype">intent(in)</span>,  &amp;</div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;                                   <span class="keywordtype">optional</span> :: do_i_in<span class="comment">  !&lt; A logical array indicating which columns</span></div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;<span class="comment">                                                        !! to work on.</span></div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,     <span class="keywordtype">intent(out)</span>, &amp;</div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;                                   <span class="keywordtype">optional</span> :: f_lim_maxent<span class="comment"> !&lt; If present, do not apply the limit in</span></div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;<span class="comment">                                                        !! finding the maximum value, but return the</span></div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;<span class="comment">                                                        !! limited value at ent=max_ent_in in this</span></div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;<span class="comment">                                                        !! array, in H.</span></div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span>,     <span class="keywordtype">intent(in)</span>,  &amp;</div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;                                   <span class="keywordtype">optional</span> :: f_thresh<span class="comment"> !&lt; If F_thresh is present, return the first</span></div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;<span class="comment">                                                        !! value found that has F &gt; F_thresh, or</span></div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;<span class="comment">                                                        !! the maximum.</span></div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;</div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;<span class="comment">! Arguments: h_bl - Layer thickness, in m or kg m-2 (abbreviated as H below).</span></div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;<span class="comment">!  (in)      Sref - Reference potential density (in kg m-3?)</span></div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;<span class="comment">!  (in)      Ent_bl - The average entrainment upward and downward across</span></div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;<span class="comment">!                     each interface around the buffer layers, in H.</span></div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;<span class="comment">!  (in)      I_dSkbp1 - The inverse of the difference in reference potential</span></div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;<span class="comment">!                       density across the base of the uppermost interior layer,</span></div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;<span class="comment">!                       in units of m3 kg-1.</span></div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;<span class="comment">!  (in)      min_ent_in - The minimum value of ent to search, in H.</span></div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;<span class="comment">!  (in)      max_ent_in - The maximum value of ent to search, in H.</span></div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;<span class="comment">!  (in)      is, ie - The range of i-indices to work on.</span></div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;<span class="comment">!  (in)      G - The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;<span class="comment">!  (in)      GV - The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;<span class="comment">!  (in)      CS - This module&#39;s control structure.</span></div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;<span class="comment">!  (out)     maxF - The maximum value of F = ent*ds_kb*I_dSkbp1 found in the</span></div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;<span class="comment">!                   range min_ent &lt; ent &lt; max_ent, in H.</span></div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;<span class="comment">!  (out,opt) ent_maxF - The value of ent at that maximum, in H.</span></div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;<span class="comment">!  (in, opt) do_i_in - A logical array indicating which columns to work on.</span></div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;<span class="comment">!  (out,opt) F_lim_maxent - If present, do not apply the limit in finding the</span></div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;<span class="comment">!                           maximum value, but return the limited value at</span></div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;<span class="comment">!                           ent=max_ent_in in this array, in H.</span></div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;<span class="comment">!  (in, opt) F_thresh - If F_thresh is present, return the first value found</span></div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;<span class="comment">!                       that has F &gt; F_thresh, or the maximum.</span></div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;</div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;<span class="comment">! Maximize F = ent*ds_kb*I_dSkbp1 in the range min_ent &lt; ent &lt; max_ent.</span></div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;<span class="comment">! ds_kb may itself be limited to positive values in determine_dSkb, which gives</span></div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;<span class="comment">! the prospect of two local maxima in the range - one at max_ent_in with that</span></div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;<span class="comment">! minimum value of ds_kb, and the other due to the unlimited (potentially</span></div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;<span class="comment">! negative) value.  It is faster to find the true maximum by first finding the</span></div><div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;<span class="comment">! unlimited maximum and comparing it to the limited value at max_ent_in.</span></div><div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: &amp;</div><div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;    ent, &amp;</div><div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;    minent, maxent, ent_best, &amp;</div><div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;    f_max_ent_in, &amp;</div><div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;    f_maxent, f_minent, f, f_best, &amp;</div><div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;    df_dent, df_de_max, df_de_min, df_de_best, &amp;</div><div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;    ds_kb, ds_kb_lim, ddskb_de, ds_anom_lim, &amp;</div><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;    chg_prev, chg_pre_prev</div><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;  <span class="keywordtype">real</span> :: df_de_mean, maxslope, minslope</div><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;  <span class="keywordtype">real</span> :: tolerance</div><div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;  <span class="keywordtype">real</span> :: ratio_select_end</div><div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;  <span class="keywordtype">real</span> :: rat, max_chg, min_chg, chg1, chg2, chg</div><div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: do_i, last_it, need_bracket, may_use_best</div><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;  <span class="keywordtype">logical</span> :: doany, ok1, ok2, bisect, new_min_bound</div><div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;  <span class="keywordtype">integer</span> :: i, it, is1, ie1</div><div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;  <span class="keywordtype">integer</span>, <span class="keywordtype">parameter</span> :: maxit = 20</div><div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;</div><div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;  tolerance = gv%m_to_H * cs%Tolerance_Ent</div><div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;</div><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(do_i_in)) <span class="keywordflow">then</span></div><div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; do_i(i) = do_i_in(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;    <span class="keywordflow">do</span> i=is,ie ; do_i(i) = .true. ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;</div><div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;  <span class="comment">! The most likely value is at max_ent.</span></div><div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;  <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, max_ent_in, is, ie, kmb, g, gv, .false., &amp;</div><div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;                      ds_kb, ddskb_de , ds_anom_lim=ds_anom_lim)</div><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;  ie1 = is-1 ; doany = .false.</div><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;  <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;    ds_kb_lim(i) = ds_kb(i) + ds_anom_lim(i)</div><div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;    f_max_ent_in(i) = max_ent_in(i)*ds_kb_lim(i)*i_dskbp1(i)</div><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;    maxent(i) = max_ent_in(i) ; minent(i) = min_ent_in(i)</div><div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;    <span class="keywordflow">if</span> ((abs(maxent(i) - minent(i)) &lt; tolerance) .or. (.not.do_i(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;      f_best(i) = max_ent_in(i)*ds_kb(i)*i_dskbp1(i)</div><div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;      ent_best(i) = max_ent_in(i) ; ent(i) = max_ent_in(i)</div><div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;      do_i(i) = .false.</div><div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;      f_maxent(i) = maxent(i) * ds_kb(i) * i_dskbp1(i)</div><div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;      df_de_max(i) = (ds_kb(i) + maxent(i)*ddskb_de(i)) * i_dskbp1(i)</div><div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;      doany = .true. ; last_it(i) = .false. ; need_bracket(i) = .true.</div><div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;</div><div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;  <span class="keywordflow">if</span> (doany) <span class="keywordflow">then</span></div><div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;    ie1 = is-1 ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) ie1 = i ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;    <span class="keywordflow">do</span> i=ie1,is,-1 ; <span class="keywordflow">if</span> (do_i(i)) is1 = i ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;    <span class="comment">! Find the value of F and its derivative at min_ent.</span></div><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;    <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, minent, is1, ie1, kmb, g, gv, .false., &amp;</div><div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;                        ds_kb, ddskb_de, do_i_in = do_i)</div><div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;    <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;      f_minent(i) = minent(i) * ds_kb(i) * i_dskbp1(i)</div><div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;      df_de_min(i) = (ds_kb(i) + minent(i)*ddskb_de(i)) * i_dskbp1(i)</div><div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;<span class="keywordflow">    endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;</div><div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;    ratio_select_end = 0.9</div><div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;    <span class="keywordflow">do</span> it=1,maxit</div><div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;      ratio_select_end = 0.5*ratio_select_end</div><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;      <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;        <span class="keywordflow">if</span> (need_bracket(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;          df_de_mean = (f_maxent(i) - f_minent(i)) / (maxent(i) - minent(i))</div><div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;          maxslope = max(df_de_mean, df_de_min(i), df_de_max(i))</div><div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;          minslope = min(df_de_mean, df_de_min(i), df_de_max(i))</div><div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;          <span class="keywordflow">if</span> (f_minent(i) &gt;= f_maxent(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;            <span class="keywordflow">if</span> (df_de_min(i) &gt; 0.0) <span class="keywordflow">then</span> ; rat = 0.02 <span class="comment">! A small step should bracket the soln.</span></div><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;            <span class="keywordflow">elseif</span> (maxslope &lt; ratio_select_end*minslope) <span class="keywordflow">then</span></div><div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;              <span class="comment">! The maximum of F is at minent.</span></div><div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;              f_best(i) = f_minent(i) ; ent_best(i) = minent(i) ; rat = 0.0</div><div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;              do_i(i) = .false.</div><div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;            <span class="keywordflow">else</span> ; rat = 0.382 ;<span class="keywordflow"> endif</span> <span class="comment">! Use the golden ratio</span></div><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;            <span class="keywordflow">if</span> (df_de_max(i) &lt; 0.0) <span class="keywordflow">then</span> ; rat = 0.98 <span class="comment">! A small step should bracket the soln.</span></div><div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;            <span class="keywordflow">elseif</span> (minslope &gt; ratio_select_end*maxslope) <span class="keywordflow">then</span></div><div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;              <span class="comment">! The maximum of F is at maxent.</span></div><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;              f_best(i) = f_maxent(i) ; ent_best(i) = maxent(i) ; rat = 1.0</div><div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;              do_i(i) = .false.</div><div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;            <span class="keywordflow">else</span> ; rat = 0.618 ;<span class="keywordflow"> endif</span> <span class="comment">! Use the golden ratio</span></div><div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;</div><div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;          <span class="keywordflow">if</span> (rat &gt;= 0.0) ent(i) = rat*maxent(i) + (1.0-rat)*minent(i)</div><div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;          <span class="keywordflow">if</span> (((maxent(i) - minent(i)) &lt; tolerance) .or. (it==maxit)) &amp;</div><div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;            last_it(i) = .true.</div><div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;        <span class="keywordflow">else</span> <span class="comment">! The maximum is bracketed by minent, ent_best, and maxent.</span></div><div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;          chg1 = 2.0*(maxent(i) - minent(i)) ; chg2 = chg1</div><div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;          <span class="keywordflow">if</span> (df_de_best(i) &gt; 0) <span class="keywordflow">then</span></div><div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;            max_chg = maxent(i) - ent_best(i) ; min_chg = 0.0</div><div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;            max_chg = 0.0 ; min_chg = minent(i) - ent_best(i) <span class="comment">! &lt; 0</span></div><div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;          <span class="keywordflow">if</span> (max_chg - min_chg &lt; 2.0*tolerance) last_it(i) = .true.</div><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;          <span class="keywordflow">if</span> (df_de_max(i) /= df_de_best(i)) &amp;</div><div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;            chg1 = (maxent(i) - ent_best(i))*df_de_best(i) / &amp;</div><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;                   (df_de_best(i) - df_de_max(i))</div><div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;          <span class="keywordflow">if</span> (df_de_min(i) /= df_de_best(i)) &amp;</div><div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;            chg2 = (minent(i) - ent_best(i))*df_de_best(i) / &amp;</div><div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;                   (df_de_best(i) - df_de_min(i))</div><div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;          ok1 = ((chg1 &lt; max_chg) .and. (chg1 &gt; min_chg))</div><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;          ok2 = ((chg2 &lt; max_chg) .and. (chg2 &gt; min_chg))</div><div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;          <span class="keywordflow">if</span> (.not.(ok1 .or. ok2)) <span class="keywordflow">then</span> ; bisect = .true. ; <span class="keywordflow">else</span></div><div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;            <span class="keywordflow">if</span> (ok1 .and. ok2) <span class="keywordflow">then</span> <span class="comment">! Take the acceptable smaller change.</span></div><div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;              chg = chg1 ; <span class="keywordflow">if</span> (abs(chg2) &lt; abs(chg1)) chg = chg2</div><div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;            <span class="keywordflow">elseif</span> (ok1) <span class="keywordflow">then</span> ; chg = chg1</div><div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;            <span class="keywordflow">else</span> ; chg = chg2 ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;            <span class="keywordflow">if</span> (abs(chg) &gt; 0.5*abs(chg_pre_prev(i))) <span class="keywordflow">then</span> ; bisect = .true.</div><div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;            <span class="keywordflow">else</span> ; bisect = .false. ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;          chg_pre_prev(i) = chg_prev(i)</div><div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;          <span class="keywordflow">if</span> (bisect) <span class="keywordflow">then</span></div><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;            <span class="keywordflow">if</span> (df_de_best(i) &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;              ent(i) = 0.5*(maxent(i) + ent_best(i))</div><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;              chg_prev(i) = 0.5*(maxent(i) - ent_best(i))</div><div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;              ent(i) = 0.5*(minent(i) + ent_best(i))</div><div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;              chg_prev(i) = 0.5*(minent(i) - ent_best(i))</div><div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;            <span class="keywordflow">if</span> (abs(chg) &lt; tolerance) chg = sign(tolerance,chg)</div><div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;            ent(i) = ent_best(i) + chg</div><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;            chg_prev(i) = chg</div><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;</div><div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;      <span class="keywordflow">if</span> (mod(it,3) == 0) <span class="keywordflow">then</span>  <span class="comment">! Re-determine the loop bounds.</span></div><div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;        ie1 = is-1 ; <span class="keywordflow">do</span> i=is1,ie ; <span class="keywordflow">if</span> (do_i(i)) ie1 = i ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;        <span class="keywordflow">do</span> i=ie1,is,-1 ; <span class="keywordflow">if</span> (do_i(i)) is1 = i ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;</div><div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;      <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, ent, is1, ie1, kmb, g, gv, .false., &amp;</div><div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;                          ds_kb, ddskb_de, do_i_in = do_i)</div><div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;      <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;        f(i) = ent(i)*ds_kb(i)*i_dskbp1(i)</div><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;        df_dent(i) = (ds_kb(i) + ent(i)*ddskb_de(i)) * i_dskbp1(i)</div><div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;</div><div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">present</span>(f_thresh)) <span class="keywordflow">then</span> ; <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;        <span class="keywordflow">if</span> (f(i) &gt;= f_thresh(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;          f_best(i) = f(i) ; ent_best(i) = ent(i) ; do_i(i) = .false.</div><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;</div><div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;      doany = .false.</div><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;      <span class="keywordflow">do</span> i=is1,ie1 ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;        <span class="keywordflow">if</span> (.not.last_it(i)) doany = .true.</div><div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;        <span class="keywordflow">if</span> (last_it(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;          <span class="keywordflow">if</span> (need_bracket(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;            <span class="keywordflow">if</span> ((f(i) &gt; f_maxent(i)) .and. (f(i) &gt; f_minent(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;              f_best(i) = f(i) ; ent_best(i) = ent(i)</div><div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;            <span class="keywordflow">elseif</span> (f_maxent(i) &gt; f_minent(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;              f_best(i) = f_maxent(i) ; ent_best(i) = maxent(i)</div><div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;              f_best(i) = f_minent(i) ; ent_best(i) = minent(i)</div><div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;          <span class="keywordflow">elseif</span> (f(i) &gt; f_best(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;            f_best(i) = f(i) ; ent_best(i) = ent(i)</div><div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;          do_i(i) = .false.</div><div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;        <span class="keywordflow">elseif</span> (need_bracket(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;          <span class="keywordflow">if</span> ((f(i) &gt; f_maxent(i)) .and. (f(i) &gt; f_minent(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;            need_bracket(i) = .false. <span class="comment">! The maximum is now bracketed.</span></div><div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;            chg_prev(i) = (maxent(i) - minent(i))</div><div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;            chg_pre_prev(i) = 2.0*chg_prev(i)</div><div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;            ent_best(i) = ent(i) ; f_best(i) = f(i) ; df_de_best(i) = df_dent(i)</div><div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;          <span class="keywordflow">elseif</span> ((f(i) &lt;= f_maxent(i)) .and. (f(i) &gt; f_minent(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;            new_min_bound = .true.  <span class="comment">! We have a new minimum bound.</span></div><div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;          <span class="keywordflow">elseif</span> ((f(i) &lt;= f_maxent(i)) .and. (f(i) &gt; f_minent(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;            new_min_bound = .false. <span class="comment">! We have a new maximum bound.</span></div><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;          <span class="keywordflow">else</span> <span class="comment">! This case would bracket a minimum.  Wierd.</span></div><div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;             <span class="comment">! Unless the derivative indicates that there is a maximum near the</span></div><div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;             <span class="comment">! lower bound, try keeping the end with the larger value of F;</span></div><div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;             <span class="comment">! in a tie keep the minimum as the answer here will be compared</span></div><div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;             <span class="comment">! with the maximum input value later.</span></div><div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;             new_min_bound = .true.</div><div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;             <span class="keywordflow">if</span> (df_de_min(i) &gt; 0.0 .or. (f_minent(i) &gt;= f_maxent(i))) &amp;</div><div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;               new_min_bound = .false.</div><div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;          <span class="keywordflow">if</span> (need_bracket(i)) <span class="keywordflow">then</span> <span class="comment">! Still not bracketed.</span></div><div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;            <span class="keywordflow">if</span> (new_min_bound) <span class="keywordflow">then</span></div><div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;              minent(i) = ent(i) ; f_minent(i) = f(i) ; df_de_min(i) = df_dent(i)</div><div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;              maxent(i) = ent(i) ; f_maxent(i) = f(i) ; df_de_max(i) = df_dent(i)</div><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;        <span class="keywordflow">else</span>  <span class="comment">! The root was previously bracketed.</span></div><div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;          <span class="keywordflow">if</span> (f(i) &gt;= f_best(i)) <span class="keywordflow">then</span> <span class="comment">! There is a new maximum.</span></div><div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;            <span class="keywordflow">if</span> (ent(i) &gt; ent_best(i)) <span class="keywordflow">then</span> <span class="comment">! Replace minent with ent_prev.</span></div><div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;              minent(i) = ent_best(i) ; f_minent(i) = f_best(i) ; df_de_min(i) = df_de_best(i)</div><div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;            <span class="keywordflow">else</span> <span class="comment">! Replace maxent with ent_best.</span></div><div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;              maxent(i) = ent_best(i) ; f_maxent(i) = f_best(i) ; df_de_max(i) = df_de_best(i)</div><div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;            ent_best(i) = ent(i) ; f_best(i) = f(i) ; df_de_best(i) = df_dent(i)</div><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;            <span class="keywordflow">if</span> (ent(i) &lt; ent_best(i)) <span class="keywordflow">then</span> <span class="comment">! Replace the minent with ent.</span></div><div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;              minent(i) = ent(i) ; f_minent(i) = f(i) ; df_de_min(i) = df_dent(i)</div><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;            <span class="keywordflow">else</span> <span class="comment">! Replace maxent with ent_prev.</span></div><div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;              maxent(i) = ent(i) ; f_maxent(i) = f(i) ; df_de_max(i) = df_dent(i)</div><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;<span class="keywordflow">            endif</span></div><div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;<span class="keywordflow">          endif</span></div><div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;          <span class="keywordflow">if</span> ((maxent(i) - minent(i)) &lt;= tolerance) do_i(i) = .false. <span class="comment">! Done.</span></div><div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;<span class="keywordflow">        endif</span> <span class="comment">! need_bracket.</span></div><div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;<span class="keywordflow">      endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;      <span class="keywordflow">if</span> (.not.doany) <span class="keywordflow">exit</span></div><div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;</div><div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">present</span>(f_lim_maxent)) <span class="keywordflow">then</span></div><div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;    <span class="comment">! Return the unlimited maximum in maxF, and the limited value of F at maxent.</span></div><div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;      maxf(i) = f_best(i)</div><div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;      f_lim_maxent(i) = f_max_ent_in(i)</div><div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">present</span>(ent_maxf)) ent_maxf(i) = ent_best(i)</div><div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;    <span class="comment">! Now compare the two? potential maxima using the limited value of dF_kb.</span></div><div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;    doany = .false.</div><div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;      may_use_best(i) = (ent_best(i) /= max_ent_in(i))</div><div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;      <span class="keywordflow">if</span> (may_use_best(i)) doany = .true.</div><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;    <span class="keywordflow">if</span> (doany) <span class="keywordflow">then</span></div><div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;      <span class="comment">! For efficiency, could save previous value of dS_anom_lim_best?</span></div><div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;      <span class="keyword">call </span>determine_dskb(h_bl, sref, ent_bl, ent_best, is, ie, kmb, g, gv, .true., &amp;</div><div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;                          ds_kb_lim)</div><div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;      <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;        f_best(i) = ent_best(i)*ds_kb_lim(i)*i_dskbp1(i)</div><div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;        <span class="comment">! The second test seems necessary because of roundoff differences that</span></div><div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;        <span class="comment">! can arise during compilation.</span></div><div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;        <span class="keywordflow">if</span> ((f_best(i) &gt; f_max_ent_in(i)) .and. (may_use_best(i))) <span class="keywordflow">then</span></div><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;          maxf(i) = f_best(i)</div><div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;          <span class="keywordflow">if</span> (<span class="keyword">present</span>(ent_maxf)) ent_maxf(i) = ent_best(i)</div><div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;          maxf(i) = f_max_ent_in(i)</div><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;          <span class="keywordflow">if</span> (<span class="keyword">present</span>(ent_maxf)) ent_maxf(i) = max_ent_in(i)</div><div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;<span class="keywordflow">      enddo</span></div><div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;      <span class="comment">! All of the maxima are at the maximum entrainment.</span></div><div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;      <span class="keywordflow">do</span> i=is,ie ; maxf(i) = f_max_ent_in(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">present</span>(ent_maxf)) <span class="keywordflow">then</span></div><div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;        <span class="keywordflow">do</span> i=is,ie ; ent_maxf(i) = max_ent_in(i) ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;<span class="keywordflow">  endif</span></div><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_ae45dbf976314c3a9e278ebcebedab109_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_ae45dbf976314c3a9e278ebcebedab109_icgraph.svg" width="568" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4cb7f6c11941a32adc279456c4c165ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb7f6c11941a32adc279456c4c165ad">&#9670;&nbsp;</a></span>set_ent_bl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mom_entrain_diffusive::set_ent_bl </td>
          <td>(</td>
          <td class="paramtype">real, dimension(szi_(g),szj_(g),szk_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(szi_(g),szk_(g)+1), intent(in)&#160;</td>
          <td class="paramname"><em>dtKd_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(thermo_var_ptrs), intent(in)&#160;</td>
          <td class="paramname"><em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(szi_(g)), intent(inout)&#160;</td>
          <td class="paramname"><em>kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>kmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension(szi_(g)), intent(in)&#160;</td>
          <td class="paramname"><em>do_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(ocean_grid_type), intent(in)&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(verticalgrid_type), intent(in)&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmom__entrain__diffusive_1_1entrain__diffusive__cs.html">entrain_diffusive_cs</a>), pointer&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %ke+1), intent(out)&#160;</td>
          <td class="paramname"><em>Ent_bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %ke), intent(out)&#160;</td>
          <td class="paramname"><em>Sref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( g %isd: g %ied, g %ke), intent(out)&#160;</td>
          <td class="paramname"><em>h_bl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subroutine sets the average entrainment across each of the interfaces between buffer layers within a timestep. It also causes thin and relatively light interior layers to be entrained by the deepest buffer layer. Also find the initial coordinate potential densities (Sref) of each layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>The ocean's grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gv</td><td>The ocean's vertical grid structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Layer thicknesses, in H</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtkd_int</td><td>The diapycnal diffusivity across</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tv</td><td>A structure containing pointers to any available thermodynamic fields. Absent fields have NULL ptrs.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">kb</td><td>The index of the lightest layer denser than the buffer layer or 1 if there is no buffer layer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_i</td><td>A logical variable indicating which i-points to work on.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cs</td><td>This module's control structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The meridional index upon which to work.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ent_bl</td><td>The average entrainment upward and</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sref</td><td>The coordinate potential density - 1000 for each layer, in kg m-3.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h_bl</td><td>The thickness of each layer, in H. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l01091">1091</a> of file <a class="el" href="MOM__entrain__diffusive_8F90_source.html">MOM_entrain_diffusive.F90</a>.</p>

<p class="reference">Referenced by <a class="el" href="MOM__entrain__diffusive_8F90_source.html#l00111">entrainment_diffusive()</a>.</p>
<div class="fragment"><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;  <span class="keywordtype">type</span>(ocean_grid_type),            <span class="keywordtype">intent(in)</span>    :: g<span class="comment">    !&lt; The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;  <span class="keywordtype">type</span>(verticalgrid_type),          <span class="keywordtype">intent(in)</span>    :: gv<span class="comment">   !&lt; The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZJ_(G),SZK_(G))</span>, &amp;</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;                                    <span class="keywordtype">intent(in)</span>    :: h<span class="comment">    !&lt; Layer thicknesses, in H</span></div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="comment">                                                          !! (usually m or kg m-2).</span></div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G)+1)</span>,       &amp;</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;                                    <span class="keywordtype">intent(in)</span>    :: dtkd_int<span class="comment"> !&lt; The diapycnal diffusivity across</span></div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;<span class="comment">                                                          !! each interface times the time step,</span></div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;<span class="comment">                                                          !! in H2.</span></div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;  <span class="keywordtype">type</span>(thermo_var_ptrs),            <span class="keywordtype">intent(in)</span>    :: tv<span class="comment">   !&lt; A structure containing pointers to any</span></div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;<span class="comment">                                                          !! available thermodynamic fields. Absent</span></div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="comment">                                                          !! fields have NULL ptrs.</span></div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;  <span class="keywordtype">integer</span>, <span class="keywordtype">dimension(SZI_(G))</span>,      <span class="keywordtype">intent(inout)</span> :: kb<span class="comment">   !&lt; The index of the lightest layer denser</span></div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;<span class="comment">                                                          !! than the buffer layer or 1 if there is</span></div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="comment">                                                          !! no buffer layer.</span></div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;  <span class="keywordtype">integer</span>,                          <span class="keywordtype">intent(in)</span>    :: kmb</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;  <span class="keywordtype">logical</span>, <span class="keywordtype">dimension(SZI_(G))</span>,      <span class="keywordtype">intent(in)</span>    :: do_i<span class="comment"> !&lt; A logical variable indicating which</span></div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="comment">                                                          !! i-points to work on.</span></div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;  <span class="keywordtype">type</span>(entrain_diffusive_cs),       <span class="keywordtype">pointer</span>       :: cs<span class="comment">   !&lt; This module&#39;s control structure.</span></div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;  <span class="keywordtype">integer</span>,                          <span class="keywordtype">intent(in)</span>    :: j<span class="comment">    !&lt; The meridional index upon which</span></div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="comment">                                                          !! to work.</span></div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G)+1)</span>,       &amp;</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;                                    <span class="keywordtype">intent(out)</span>   :: ent_bl<span class="comment"> !&lt; The average entrainment upward and</span></div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="comment">                                                          !! downward across each interface around</span></div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="comment">                                                          !! the buffer layers, in H.</span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, <span class="keywordtype">intent(out)</span>   :: sref<span class="comment"> !&lt; The coordinate potential density -</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="comment">                                                          !! 1000 for each layer, in kg m-3.</span></div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G),SZK_(G))</span>, <span class="keywordtype">intent(out)</span>   :: h_bl<span class="comment"> !&lt; The thickness of each layer, in H.</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="comment">! Arguments: h - Layer thickness, in m or kg m-2 (abbreviated as H below).</span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="comment">!  (in)      dtKd_int - The diapycnal diffusivity across each interface times</span></div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="comment">!                       the time step, in H2.</span></div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="comment">!  (in)      tv - A structure containing pointers to any available</span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="comment">!                 thermodynamic fields. Absent fields have NULL ptrs.</span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="comment">!  (in)      kb - The index of the lightest layer denser than the</span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="comment">!                 buffer layer or 1 if there is no buffer layer.</span></div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="comment">!  (in)      do_i - A logical variable indicating which i-points to work on.</span></div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;<span class="comment">!  (in)      G - The ocean&#39;s grid structure.</span></div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="comment">!  (in)      GV - The ocean&#39;s vertical grid structure.</span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="comment">!  (in)      CS - This module&#39;s control structure.</span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="comment">!  (in)      j - The meridional index upon which to work.</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="comment">!  (out)     Ent_bl - The average entrainment upward and downward across</span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="comment">!                     each interface around the buffer layers, in H.</span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="comment">!  (out)     Sref - The coordinate potential density - 1000 for each layer,</span></div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="comment">!                   in kg m-3.</span></div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="comment">!  (out)     h_bl - The thickness of each layer, in H.</span></div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="comment">!   This subroutine sets the average entrainment across each of the interfaces</span></div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="comment">! between buffer layers within a timestep. It also causes thin and relatively</span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="comment">! light interior layers to be entrained by the deepest buffer layer.</span></div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="comment">!   Also find the initial coordinate potential densities (Sref) of each layer.</span></div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="comment">! Does there need to be limiting when the layers below are all thin?</span></div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G))</span> :: &amp;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;    b1, d1, &amp;   <span class="comment">! Variables used by the tridiagonal solver, in H-1 and ND.</span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;    rcv, &amp;      <span class="comment">! Value of the coordinate variable (potential density)</span></div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;                <span class="comment">! based on the simulated T and S and P_Ref, kg m-3.</span></div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;    pres, &amp;     <span class="comment">! Reference pressure (P_Ref) in Pa.</span></div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    frac_rem, &amp; <span class="comment">! The fraction of the diffusion remaining, ND.</span></div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    h_interior  <span class="comment">! The interior thickness available for entrainment, in H.</span></div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;  <span class="keywordtype">real</span>, <span class="keywordtype">dimension(SZI_(G), SZK_(G))</span> :: &amp;</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;    s_est <span class="comment">! An estimate of the coordinate potential density - 1000 after</span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;          <span class="comment">! entrainment for each layer, in kg m-3.</span></div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;  <span class="keywordtype">real</span> :: max_ent  <span class="comment">! The maximum possible entrainment, in H.</span></div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;  <span class="keywordtype">real</span> :: dh       <span class="comment">! An available thickness, in H.</span></div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;  <span class="keywordtype">real</span> :: kd_x_dt  <span class="comment">! The diffusion that remains after thin layers are</span></div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;                   <span class="comment">! entrained, in H2.</span></div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;  <span class="keywordtype">real</span> :: h_neglect <span class="comment">! A thickness that is so small it is usually lost</span></div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;                    <span class="comment">! in roundoff and can be neglected, in H.</span></div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;  <span class="keywordtype">integer</span> :: i, k, is, ie, nz</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;  is = g%isc ; ie = g%iec ; nz = g%ke</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="comment">!  max_ent = 1.0e14*GV%Angstrom ! This is set to avoid roundoff problems.</span></div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;  max_ent = 1.0e4*gv%m_to_H</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;  h_neglect = gv%H_subroundoff</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;  <span class="keywordflow">do</span> i=is,ie ; pres(i) = tv%P_Ref ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;  <span class="keywordflow">do</span> k=1,kmb</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    <span class="keyword">call </span>calculate_density(tv%T(is:ie,j,k), tv%S(is:ie,j,k), pres(is:ie), &amp;</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;                           rcv(is:ie), 1, ie-is+1, tv%eqn_of_state)</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;    <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;      h_bl(i,k) = h(i,j,k) + h_neglect</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;      sref(i,k) = rcv(i) - 1000.0</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;<span class="keywordflow">    enddo</span></div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;  <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;    h_interior(i) = 0.0 ; ent_bl(i,1) = 0.0</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;<span class="comment">!     if (kb(i) &gt; nz) Ent_bl(i,Kmb+1) = 0.0</span></div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;  <span class="keywordflow">do</span> k=2,kmb ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;      ent_bl(i,k) = min(2.0 * dtkd_int(i,k) / (h(i,j,k-1) + h(i,j,k) + h_neglect), &amp;</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;                        max_ent)</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;    <span class="keywordflow">else</span> ; ent_bl(i,k) = 0.0 ;<span class="keywordflow"> endif</span></div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;<span class="keywordflow">  enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;  <span class="comment">!   Determine the coordinate density of the bottommost buffer layer if there</span></div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;  <span class="comment">! is no entrainment from the layers below.  This is a partial solver, based</span></div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;  <span class="comment">! on the first pass of a tridiagonal solver, as the values in the upper buffer</span></div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;  <span class="comment">! layers are not needed.</span></div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;  <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;    b1(i) = 1.0 / (h_bl(i,1) + ent_bl(i,2))</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;    d1(i) = h_bl(i,1) * b1(i)  <span class="comment">! = 1.0 - Ent_bl(i,2)*b1(i)</span></div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;    s_est(i,1) = (h_bl(i,1)*sref(i,1)) * b1(i)</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;  <span class="keywordflow">do</span> k=2,kmb-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;    b1(i) = 1.0 / ((h_bl(i,k) + ent_bl(i,k+1)) + d1(i)*ent_bl(i,k))</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;    d1(i) = (h_bl(i,k) + d1(i)*ent_bl(i,k)) * b1(i)  <span class="comment">! = 1.0 - Ent_bl(i,K+1)*b1(i)</span></div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;    s_est(i,k) = (h_bl(i,k)*sref(i,k) + ent_bl(i,k)*s_est(i,k-1)) * b1(i)</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="keywordflow">  enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;  <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;    s_est(i,kmb) = (h_bl(i,kmb)*sref(i,kmb) + ent_bl(i,kmb)*s_est(i,kmb-1)) / &amp;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;                   (h_bl(i,kmb) + d1(i)*ent_bl(i,kmb))</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;    frac_rem(i) = 1.0</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="keywordflow">  enddo</span></div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;  <span class="comment">!   Entrain any thin interior layers that are lighter (in the coordinate</span></div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;  <span class="comment">! potential density) than the deepest buffer layer will be, and adjust kb.</span></div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;  <span class="keywordflow">do</span> i=is,ie ; kb(i) = nz+1 ; <span class="keywordflow">if</span> (do_i(i)) kb(i) = kmb+1 ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;  <span class="keywordflow">do</span> k=kmb+1,nz ; <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;    <span class="keywordflow">if</span> ((k == kb(i)) .and. (s_est(i,kmb) &gt; (gv%Rlay(k) - 1000.0))) <span class="keywordflow">then</span></div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;      <span class="keywordflow">if</span> (4.0*dtkd_int(i,kmb+1)*frac_rem(i) &gt; &amp;</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;          (h_bl(i,kmb) + h(i,j,k)) * (h(i,j,k) - gv%Angstrom)) <span class="keywordflow">then</span></div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;        <span class="comment">! Entrain this layer into the buffer layer and move kb down.</span></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;        dh = max((h(i,j,k) - gv%Angstrom), 0.0)</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;        <span class="keywordflow">if</span> (dh &gt; 0.0) <span class="keywordflow">then</span></div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;          frac_rem(i) = frac_rem(i) - ((h_bl(i,kmb) + h(i,j,k)) * dh) / &amp;</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;                                       (4.0*dtkd_int(i,kmb+1))</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;          sref(i,kmb) = (h_bl(i,kmb)*sref(i,kmb) + dh*(gv%Rlay(k)-1000.0)) / &amp;</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;                        (h_bl(i,kmb) + dh)</div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;          h_bl(i,kmb) = h_bl(i,kmb) + dh</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;          s_est(i,kmb) = (h_bl(i,kmb)*sref(i,kmb) + ent_bl(i,kmb)*s_est(i,kmb-1)) / &amp;</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;                         (h_bl(i,kmb) + d1(i)*ent_bl(i,kmb))</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;<span class="keywordflow">        endif</span></div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;        kb(i) = kb(i) + 1</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;<span class="keywordflow">      endif</span></div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160; <span class="comment">!    This is where variables are be set up with a different vertical grid</span></div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160; <span class="comment">!  in which the (newly?) massless layers are taken out.</span></div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;  <span class="keywordflow">do</span> k=nz,kmb+1,-1 ; <span class="keywordflow">do</span> i=is,ie</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;    <span class="keywordflow">if</span> (k &gt;= kb(i)) h_interior(i) = h_interior(i) + (h(i,j,k)-gv%Angstrom)</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;    <span class="keywordflow">if</span> (k==kb(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;      h_bl(i,kmb+1) = h(i,j,k) ; sref(i,kmb+1) = gv%Rlay(k) - 1000.0</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;    <span class="keywordflow">elseif</span> (k==kb(i)+1) <span class="keywordflow">then</span></div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;      h_bl(i,kmb+2) = h(i,j,k) ; sref(i,kmb+2) = gv%Rlay(k) - 1000.0</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;<span class="keywordflow">  enddo</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;  <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (kb(i) &gt;= nz) <span class="keywordflow">then</span></div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    h_bl(i,kmb+1) = h(i,j,nz)</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;    sref(i,kmb+1) = gv%Rlay(nz) - 1000.0</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;    h_bl(i,kmb+2) = gv%Angstrom</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    sref(i,kmb+2) = sref(i,kmb+1) + (gv%Rlay(nz) - gv%Rlay(nz-1))</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;  <span class="comment">!   Perhaps we should revisit the way that the average entrainment between the</span></div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;  <span class="comment">! buffer layer and the interior is calculated so that it is not unduly</span></div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;  <span class="comment">! limited when the layers are less than sqrt(Kd * dt) thick?</span></div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;  <span class="keywordflow">do</span> i=is,ie ; <span class="keywordflow">if</span> (do_i(i)) <span class="keywordflow">then</span></div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;    kd_x_dt = frac_rem(i) * dtkd_int(i,kmb+1)</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    <span class="keywordflow">if</span> ((kd_x_dt &lt;= 0.0) .or. (h_interior(i) &lt;= 0.0)) <span class="keywordflow">then</span></div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;      ent_bl(i,kmb+1) = 0.0</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;      <span class="comment">!   If the combined layers are exceptionally thin, use sqrt(Kd*dt) as the</span></div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;      <span class="comment">! estimate of the thickness in the denominator of the thickness diffusion.</span></div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;      ent_bl(i,kmb+1) = min(0.5*h_interior(i), sqrt(kd_x_dt), &amp;</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;                            kd_x_dt / (0.5*(h_bl(i,kmb) + h_bl(i,kmb+1))))</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;<span class="keywordflow">    endif</span></div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    ent_bl(i,kmb+1) = 0.0</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;<span class="keywordflow">  endif</span> ;<span class="keywordflow"> enddo</span></div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;</div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacemom__entrain__diffusive_a4cb7f6c11941a32adc279456c4c165ad_icgraph.svg" width="367" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemom__entrain__diffusive.html">mom_entrain_diffusive</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
